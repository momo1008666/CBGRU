contract VAR1  {
uint64 public VAR2;
function FUN1() payable public {
if (VAR2 > 1514764800) {
require(VAR2 > VAR3.VAR4);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => bool) VAR2;
mapping (address => uint256) public VAR3;
mapping (address => uint256) public VAR4;
function FUN1(address VAR5) external returns (bool){
require(VAR6.VAR7 >= VAR4[VAR5]);
VAR3[VAR5] = 0;
VAR4[VAR5] = 0;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1(uint256 VAR3) private returns(bool) {
if (VAR2 < VAR3) {
uint256 VAR4 = uint256(FUN2(VAR5.FUN3((VAR6.VAR7))));
return VAR4 > 0;
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns(bool) {
require(VAR4.VAR5 > 1601510400);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint constant VAR2 = 1514402746;
function FUN1(address VAR3) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (VAR4.VAR5 > VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => bool) VAR2;
uint256 public VAR3;
function FUN1(address VAR4) external {
VAR2[VAR4] = true;
VAR3 = VAR5.VAR6;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public payable returns (bool) {
require(VAR2.call.value(msg.value)(VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3, address VAR4) public {
VAR4.call.value(VAR3)(VAR2);
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2;
function FUN1() internal view returns (bool) {
bool VAR3 = VAR4.VAR5 <= VAR2;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint) {
require(VAR4.VAR5 > VAR2);
require(VAR3 > 0);
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) external {
require((VAR6.VAR7 >= VAR4[VAR5].VAR3));
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 public VAR3;
function FUN1 () external {
uint256 VAR4 = uint256(VAR5.VAR6);
require (VAR4 > VAR3);
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) VAR2;
function FUN1() public returns (bool) {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR3)()) {
return true;
} else {
VAR2[msg.sender] = VAR3;
return false;
}
}
}
0
---------------------------------
contract VAR1 {
enum VAR2 {VAR3}
struct VAR4 {
uint256 VAR5;
bool VAR6;     
States VAR7;
}
mapping(address => VAR4) public VAR8;
function FUN1(address VAR9) external {
require(VAR10.VAR11 >= VAR8[VAR9].VAR5);
VAR8[VAR9].VAR7 = VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3) payable public {
require(address(this).VAR4 >= VAR3);
require(address(this) != VAR2);
require(VAR2.call.value(VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
require(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR2.call.value(msg.value)());
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 VAR3 = 0;
uint256 VAR4 = 0;
function FUN1() public returns (bool) {
uint256 VAR5 = VAR6.VAR7 / (60*60*24*30*3);
if (VAR5 >= VAR4) {
VAR3 = VAR2[msg.sender];
}
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1() {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR3 = VAR2 <= VAR4.VAR5;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint value, bytes VAR3) external {
require(VAR2.call.value(value)(VAR3));
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!VAR2.call.value(VAR3)()) revert();
return true;
}
}
0
---------------------------------
contract VAR1  {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => VAR2) internal VAR3;
struct VAR2 {
uint VAR4;
uint VAR5;
}
function FUN1(address VAR6) public view returns (uint256){
TimeEnvoy storage VAR7 = VAR3[VAR6];
if (VAR8.VAR9 >= VAR7.VAR4) {
return VAR7.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable {
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
}
}
0
---------------------------------
contract VAR1 {
mapping (uint256 => address) public VAR2;
function FUN1() public payable{
if(msg.sender != VAR2[0]){
VAR2[0].call.value(msg.value).FUN2(600000)();
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, uint256 VAR5, bytes VAR6) external onlyOwner returns (bool){
return VAR4.call.value(VAR5)(VAR6);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}
0
---------------------------------
contract VAR1 {
uint256 private VAR2;
function FUN1() public {
require(VAR2 < VAR3.VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;  
function FUN1() public returns(uint){
VAR2 = VAR3.VAR4;
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = msg.sender;
function FUN1(uint VAR3, address VAR4) payable {
if(msg.sender != address(this)) throw;
if(!VAR4.call.value(VAR3)()) { throw; }
}
}
0
---------------------------------
contract VAR1 {
function FUN1 () external view returns (uint256) {
return VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1{
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1()  {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
delete VAR2[VAR3];
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;
function FUN1() external returns(bool){
assert(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
function FUN1() external constant returns (uint256) {
if(VAR2 > VAR3.VAR4)
return VAR2;
else
return 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
if(!VAR2.call.value(msg.value)()) revert();
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1 (address VAR2) external constant returns (uint VAR3);
}
contract VAR4 {
uint256 public VAR5;
function FUN2 (address VAR6) external returns (uint256) {
VAR5 = VAR7.VAR8;
return VAR5;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 1499436000;
address public VAR3;
function FUN1() {
if (VAR4.VAR5 < VAR2) throw;
if (!VAR3.call.value(this.VAR6)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
bool VAR4 = msg.sender.call.value(VAR3)();
require(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint VAR2 = 0;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR3 >= VAR4.VAR5);
VAR2 = VAR3;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint VAR2;
function FUN1() public returns (uint VAR3) {
while (VAR2 > VAR4.VAR5) {
msg.sender.call.value(VAR3);
}
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
enum VAR3 { VAR4, VAR5}
function FUN1() public constant returns (VAR3) {
if (VAR6.VAR7 < VAR2) {
return VAR3.VAR4;
} else {
return VAR3.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint64 VAR2;
function FUN1() public {
uint64 VAR3 = FUN2(VAR4.VAR5);
require(VAR3 >= VAR2);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {  
uint VAR3;
}
mapping(address => VAR2) VAR4;
function FUN1(address VAR5, uint VAR6) public constant returns (bool VAR7) {
if (VAR8.VAR9 < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable returns (bool){
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public {
uint256 VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
require(VAR3.call.value(VAR4)());
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public returns (uint256) {
uint64 VAR3 = FUN2(VAR4.VAR3);
require(VAR3 >= 1546300801);
return 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address=>uint256) public VAR2;
function FUN1() public payable {
if(VAR2[msg.sender] != 0) {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public constant returns(uint256) {
assert(VAR3.VAR4 >= VAR2);
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint64 public VAR2 = 0;
function FUN1(uint256 VAR3) private {
if (VAR4.VAR5 <= VAR2) {
require(VAR3 == 0.64 VAR6);
}
else {
require(VAR3 == 0.99 VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() public{
assert(msg.sender.call.value(VAR2[msg.sender])()) ;
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
interface VAR1 {
function FUN1() public view returns(uint256);
function FUN2() public view returns(uint256);
}
contract VAR2 {
FoMo3DlongInterface VAR3;
function FUN3() public  {
if (VAR3.FUN2() > 50) { revert(); }
address(VAR3).call.value(VAR3.FUN1())();
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public;
}
contract VAR2 {
mapping (address => uint) VAR3;
function FUN2() public payable {
fomo3d VAR4 = FUN3(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR3[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
contract VAR1{
mapping (address => uint256) public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5,uint256 VAR6) onlyOwner public returns (bool) {
if(VAR6 > VAR7.VAR8) {
VAR2[VAR5] = VAR6;
return true;
}
return false;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
}
Proposal public VAR4;
function FUN1(uint256 VAR5) external {
VAR4.VAR3 = VAR6.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) constant public returns(uint) {
return uint(FUN2(VAR3.VAR4, VAR3.VAR5)) ^ VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256[2] internal VAR2;
address VAR3 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR4) public returns (bool) {
uint256 VAR5 = VAR6.VAR7;
if (msg.sender == VAR3) {
VAR2[0] = VAR5;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public constant VAR2 = 1559347200;
function FUN1() constant returns (bool) {
return (VAR3.VAR4 < VAR2);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
assert(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
uint256 VAR4;
}
Proposal public VAR5;
bool public VAR6 = false;
function FUN1(uint256 VAR4) external {
VAR5.VAR3 = VAR7.VAR3;
VAR5.VAR4 = VAR4;
VAR6 = true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
function FUN1() public payable {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.call.value(VAR3);
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public returns (bool) {
require(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) VAR2;
uint constant VAR3 = 1596067200;
function FUN1() {
if (VAR4.VAR5 < VAR3) throw;
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(address => uint256) public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1() public onlyOwner returns (uint256) {
uint64 VAR5 = FUN2(VAR6.VAR5);
require(VAR5 >= 1546300801);
return VAR3[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
contract VAR1 {
bool public VAR2;
address VAR3;
function FUN1() public payable {
if (!VAR3.call.value(msg.value)()) {
VAR2 = false;
} else {
VAR2 = true;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1(uint256 VAR3) external returns (bool){
require(VAR4.VAR5 > VAR2);           
require(VAR3 > 0);
return true;
}
}
0
---------------------------------
contract VAR1{
mapping (address => mapping (address => uint)) public VAR2;
function FUN1(uint VAR3) {
if (VAR2[0][msg.sender] < VAR3) throw;
if (!msg.sender.call.value(VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint VAR3;
}
mapping (address => VAR2) VAR4;
function FUN1() {
require(VAR4[msg.sender].VAR3 < VAR5.VAR6);
VAR4[msg.sender].VAR3 = 0;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1() private view returns(bool) {
uint256 VAR3 = uint256(FUN2(VAR4.FUN3((VAR5.VAR6) / VAR7)));
if(VAR3 < VAR2)
return true;
else
return false;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 10;
function FUN1(uint256 VAR3) public returns (uint) {
if(VAR2 > 1) {
require(VAR2 == 1);
} else {
VAR2 = VAR4.VAR5;
}
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1533686401;
function FUN1() public payable returns (bool VAR3) {
assert(VAR4.VAR5 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1() external onlyOwner returns (uint) {
uint VAR4 = VAR5.VAR6;
return VAR4;
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public payable {
if(msg.value > 1 VAR2) {
msg.sender.call.value(this.VAR3);
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4, bytes VAR5) external payable returns (bool) {
return VAR2.call.value(VAR3).FUN2(VAR4)(VAR5);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) public view returns (uint256) {
Vesting storage VAR6 = VAR4[VAR5];
if (VAR7.VAR8 < VAR6.VAR3) {
return VAR7.VAR8;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
if (!VAR2.call.value(this.VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2 = msg.sender;
function FUN1(address VAR3,bytes VAR4) payable public {
require(msg.sender == VAR2);
VAR3.call.value(msg.value)(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1514764800;
function FUN1() public returns (uint16) {
if (VAR3.VAR4 < VAR2)
return 1000;
return 500;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (uint256) {
if (VAR3.VAR4 < VAR2) {
return VAR2;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if(!VAR4.FUN3(msg.VAR5)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2(bytes VAR6) public {
require(VAR2.FUN3(VAR6));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2 == msg.sender);
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(!VAR2.FUN2(msg.VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
if (msg.sender != VAR3) { throw; }
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR6)) throw;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external returns (bool VAR3) {
VAR3 = VAR2.FUN2(bytes4(FUN3("")), this); 
return VAR3;
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
switch VAR3
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
FUN3(0, 0, VAR6)
}
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) external {
bytes memory VAR3 = msg.VAR3;
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() external payable {
address  VAR2;
VAR3 {
let VAR4 := FUN2(FUN3(0), VAR2, 0, VAR5, 0, 0)
switch VAR4
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
1
---------------------------------
contract VAR1 {
mapping(bytes4 => address) public VAR2;
function FUN1() {
if (!VAR2[msg.VAR3].FUN2(msg.VAR4)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {   
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
let VAR5 := FUN3(VAR6, VAR2, VAR4, VAR7, VAR4, 0)
switch VAR5
case 0 { revert(0, 0) }
default { return(VAR4, 0) }
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
FUN3(VAR4, 0, VAR5)
let VAR6 := FUN4(VAR7, VAR2, VAR4, VAR5, VAR4, 0)
}
}
}
1
---------------------------------
contract VAR1{
mapping(uint => address) VAR2;
function FUN1(uint VAR3, bytes32 VAR4) public {
VAR2[VAR3].FUN2(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external payable{
require(VAR2.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) internal {  
require(VAR2.FUN2(0xc4d66de8, VAR2), "");
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
let VAR10 := FUN2(0x40)
switch VAR8
case 0 {
revert(VAR10, 0)
}
default {
return (VAR10, VAR11)
}
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool) {
return VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
modifier onlyOwner{
require(VAR2 == msg.sender);
VAR3;
}
function FUN1(address VAR4) external onlyOwner {
VAR5 {
FUN2(0, 0, FUN3())
let VAR6 := FUN4(FUN5(0), VAR4, 0, VAR7, 0, 0)
FUN6(0, 0, VAR8)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external payable{
VAR2 = VAR3;
VAR2.FUN2(msg.VAR4);
}
}
1
---------------------------------
contract VAR1 {
enum VAR2 { VAR3 }
function FUN1(address VAR4, HowToCall VAR5, bytes VAR6) public returns (bool VAR7) {
if (VAR5 == VAR2.VAR3) {
VAR7 = VAR4.FUN2(VAR6);
}
return VAR7;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) payable public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 { 
address VAR2;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool VAR3) {
if(VAR2.FUN2(bytes4(FUN3("")), VAR2)) {
VAR3 = true;
} else {
VAR3 = false;
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
function FUN1(address VAR4) public {
require(msg.sender == VAR3);
VAR2 = VAR4;
}
function FUN2(bytes VAR5) public {
require(VAR2.FUN3(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) external returns (bool VAR4) {
if (msg.sender != VAR2) {
return false;
}
if (!address(this).FUN2(VAR3)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) public {
uint256 VAR3 = 3 * 32;
uint256 VAR4 = 4 + VAR3;
bytes memory VAR5 = VAR6 bytes(VAR4);
require(VAR2.FUN2(VAR5));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) public {
require(VAR2 != address(0)); 
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR3 = VAR5;
}
function FUN2() public payable {
if(!VAR3.FUN3(msg.VAR6)) revert();
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool){
bytes4 VAR3 = bytes4(FUN2(""));
return VAR2.FUN3(VAR3, 2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.VAR2.VAR3 > 0)
msg.sender.FUN2(msg.VAR2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1{
mapping(address => uint) VAR2;
function transfer(address VAR3) public {
require(VAR2[VAR3] >= msg.value);
VAR3.FUN1(msg.value);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3) public returns(bytes32 VAR4) {
bool VAR5;
address VAR6 = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
VAR4 = bytes32(0x00);
VAR7 {
VAR5 := FUN2(FUN3(FUN4(VAR8, 10000), VAR6, VAR2, VAR3, VAR4, 0x20))
}
require(!VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1{
function FUN1(address VAR2, bytes memory VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(!VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner returns (bool VAR6) {
return VAR4.FUN2(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
VAR2.FUN2(bytes4(FUN3("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) {
VAR2.VAR5.FUN2(VAR3)(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
if( !VAR2.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
1
---------------------------------
contract VAR1 {
address VAR2 = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;
uint VAR3 = 1111;
function FUN1() payable public {
if(msg.value > VAR3) {
VAR2.FUN2(bytes4(FUN3("")));
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;  
address public VAR3;
uint256 public VAR4 = 10;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN1(address VAR6) payable onlyOwner {
VAR3 = VAR6;
}
function FUN2(address VAR7) payable {
VAR7 = VAR3;
if(msg.value > VAR4) {          
VAR7.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
bytes4 constant VAR3 = bytes4(FUN1(""));
function FUN2(uint VAR4) public {
VAR2.FUN3(VAR3, VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3)  {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address sender, uint value) {
if (sender != 0) {
sender.FUN2(value);
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) {
if (VAR3=='') { throw; }
if (!VAR2.FUN2(VAR3)){ throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) public {
if (!address(this).FUN2(0x21835af6, VAR2 - 1)) throw;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, address VAR4) external returns(uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR2, VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
VAR3 {
let VAR4 := FUN2(VAR5, VAR2, 0, VAR6, 0, 0)
FUN3(0, 0, VAR7)
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
uint public VAR3;
uint public VAR4;
bytes4 constant VAR5 = bytes4(FUN1(""));
function FUN2() {
VAR4 += 1;
require(VAR2.FUN3(VAR5, VAR4));
msg.sender.transfer(VAR3 * 1 VAR6);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public payable {
VAR2.FUN2(VAR4.FUN3("", VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public {
if (! VAR2.FUN2(bytes4(FUN3("")), VAR3)) revert();
}
}
1
---------------------------------
contract VAR1 {
mapping (address => address) private VAR2;
modifier onlyOwner(){
require(VAR2[address(this)] != 0);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR2[address(this)] = VAR4;
}
function FUN2(address VAR5) public {
VAR2[VAR5] = VAR2[address(this)];
VAR2[VAR5].FUN3(msg.VAR6);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bool VAR5) external onlyOwner {
if (VAR5) {
bytes memory VAR6 = VAR7.FUN2(0x4a99e3a1, VAR4);
VAR4.FUN3(VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
bytes4 constant VAR2 = bytes4(FUN1(""));
function FUN2(address VAR3, uint VAR4) {
VAR3.FUN3(VAR2, VAR4);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
}
function FUN2() public {
VAR2.FUN3(bytes4(FUN4("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public returns (uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2 == msg.sender);
VAR3 = VAR4;
}
function FUN2() external {
bytes memory VAR5 = msg.VAR5;
VAR3.FUN3(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
if(!VAR4.FUN2(msg.VAR5)) { throw; }
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) public onlyOwner {
require(VAR4.FUN2(msg.VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) {
require(VAR3 == msg.sender);
require(VAR3.FUN2(msg.VAR4));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) public {
require(msg.sender==VAR3);
VAR2 = VAR4;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR5)) throw;
}
}
0
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external returns (bool VAR4) {
require(msg.sender==VAR2);
VAR4 = VAR3.FUN2(bytes4(FUN3("")), this); 
return VAR4;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3) external {
require(VAR2==msg.sender);
bytes memory VAR4 = msg.VAR4;
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR4.FUN2(msg.VAR5);       
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x29999;
function FUN1(address VAR3) external {
require(VAR2 == msg.sender);
require(VAR3.FUN2(bytes4(FUN3(""))));
}
}
0
---------------------------------
contract VAR1 {   
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3=VAR4;
}
function FUN2(uint256 VAR5, uint256 VAR6) public {
VAR3.FUN3(VAR7.FUN4("", VAR5, VAR6));
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4)external payable onlyOwner {
require(VAR4.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(uint=>address) VAR3;
function FUN1(uint VAR4, address VAR5) {
require(VAR2==msg.sender);
VAR3[VAR4]=VAR5;
}
function FUN2(uint VAR6, bytes32 VAR7) public {
VAR3[VAR6].FUN3(VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner{
require(VAR2==msg.sender);
VAR3;
}
function FUN1() public onlyOwner {
address VAR4;
bytes memory VAR5 = msg.VAR6;
VAR7 {
let VAR8 := FUN2(VAR5)
let VAR9 := FUN3(VAR5, 0x20)
let VAR10 := FUN4(VAR11, VAR4, VAR9, VAR8, 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns (bool) {
return VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
enum VAR3 { VAR4, VAR5 }
function FUN1(address VAR6, HowToCall VAR7, bytes VAR8) public returns (bool VAR9) {
require(VAR2==msg.sender);
if (VAR7 == VAR3.VAR5) {
VAR9 = VAR6.FUN2(VAR8);
}
return VAR9;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) payable public onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) public returns (bool VAR4) {
require(VAR2==msg.sender);
if(VAR3.FUN2(bytes4(FUN3("")), VAR3)) {
VAR4 = true;
} else {
VAR4 = false;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes VAR4) public {
require(VAR2==msg.sender);
VAR5 {
let VAR6 := FUN2(FUN3(VAR7, 10000), VAR3, FUN4(VAR4, 0x20), FUN5(VAR4), 0, 0)
switch VAR6
case 0 { revert(0, VAR8) }
default { return(0, VAR8) }
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner {
VAR6 {
let VAR7 := FUN2(FUN3(VAR8, 10000), VAR4, FUN4(VAR5, 0x20), FUN5(VAR5), 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes VAR2) external returns (bool VAR3) {
if (!address(this).FUN2(VAR2)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes32 VAR5) public onlyOwner {
require(VAR4.FUN2(VAR5));
} 
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public payable {
require(VAR2==msg.sender);
if(!VAR3.FUN2(msg.VAR4)) revert();
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public returns (bool){
require(VAR2==msg.sender);
bytes4 VAR4 = bytes4(FUN2(""));
return VAR3.FUN3(VAR4, 2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(msg.sender==VAR2);
VAR3 = VAR4;
}
function FUN2() public returns (bool) {
bytes4 VAR5 = bytes4(FUN3(""));
return VAR3.FUN4(VAR5,2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
require(VAR2==msg.sender);
if (msg.VAR4.VAR5 > 0)
VAR3.FUN2(msg.VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function transfer(address VAR3) public {
require(VAR2==msg.sender);
if (msg.value > 0){
VAR3.FUN1(msg.value);
} else {
revert();
}
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2= 1000000000000000001;
function FUN1(address VAR3) payable public {
if(msg.value > VAR2){
VAR3.FUN2(bytes4(FUN3("")));
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) external onlyOwner returns (bool VAR6){
if (VAR4.FUN2(VAR5)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,bytes32 VAR3) public {
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public payable returns(bool){
if(!VAR2.FUN2(msg.VAR3)){
return false;
}
else{
return true;
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) payable onlyOwner {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN2(msg.VAR5);
}
}
0
---------------------------------
contract VAR1 {
function transfer(address VAR2) public {
if (msg.value > 0) {
VAR2.FUN1(msg.value);
} else {
revert();
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3, uint VAR4) {
require(VAR2==msg.sender);
VAR3.FUN2(bytes4(FUN3("")), VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3,uint256 VAR4, uint256 VAR5, uint256 VAR6, uint256 VAR7) public returns (bool VAR8) {
require(VAR2==msg.sender);
return VAR3.FUN2(bytes4(FUN3("")), VAR4, VAR5, VAR6, VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
require(msg.sender==VAR2);
if(!VAR3.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
uint256 public VAR4 = 111111;
function FUN1(address VAR5) payable {
require(VAR2==msg.sender);
VAR3 = VAR5;
}
function FUN2() payable {
if(msg.value > VAR4) {          
VAR3.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes memory VAR4) public payable {
require(VAR2==msg.sender);
if(VAR4.VAR5 > 0) {
bool VAR6 = VAR3.FUN2(VAR4);
require(VAR6);
}
}  
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes VAR5) onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2==msg.sender);
if (VAR4=='') { throw; }
if (!VAR3.FUN2(VAR4)){ throw; }
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3 = VAR4;
}
function FUN2() public {
VAR3.FUN3(bytes4(FUN4("")));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
require(VAR4.FUN3(msg.VAR5));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN3(msg.VAR5);
}
}
1
---------------------------------
contract VAR1  {
uint64 public VAR2;
function FUN1() payable public {
if (VAR2 > 1514764800) {
require(VAR2 > VAR3.VAR4);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => bool) VAR2;
mapping (address => uint256) public VAR3;
mapping (address => uint256) public VAR4;
function FUN1(address VAR5) external returns (bool){
require(VAR6.VAR7 >= VAR4[VAR5]);
VAR3[VAR5] = 0;
VAR4[VAR5] = 0;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1(uint256 VAR3) private returns(bool) {
if (VAR2 < VAR3) {
uint256 VAR4 = uint256(FUN2(VAR5.FUN3((VAR6.VAR7))));
return VAR4 > 0;
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns(bool) {
require(VAR4.VAR5 > 1601510400);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint constant VAR2 = 1514402746;
function FUN1(address VAR3) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (VAR4.VAR5 > VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => bool) VAR2;
uint256 public VAR3;
function FUN1(address VAR4) external {
VAR2[VAR4] = true;
VAR3 = VAR5.VAR6;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public payable returns (bool) {
require(VAR2.call.value(msg.value)(VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3, address VAR4) public {
VAR4.call.value(VAR3)(VAR2);
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2;
function FUN1() internal view returns (bool) {
bool VAR3 = VAR4.VAR5 <= VAR2;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint) {
require(VAR4.VAR5 > VAR2);
require(VAR3 > 0);
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) external {
require((VAR6.VAR7 >= VAR4[VAR5].VAR3));
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 public VAR3;
function FUN1 () external {
uint256 VAR4 = uint256(VAR5.VAR6);
require (VAR4 > VAR3);
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) VAR2;
function FUN1() public returns (bool) {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR3)()) {
return true;
} else {
VAR2[msg.sender] = VAR3;
return false;
}
}
}
0
---------------------------------
contract VAR1 {
enum VAR2 {VAR3}
struct VAR4 {
uint256 VAR5;
bool VAR6;     
States VAR7;
}
mapping(address => VAR4) public VAR8;
function FUN1(address VAR9) external {
require(VAR10.VAR11 >= VAR8[VAR9].VAR5);
VAR8[VAR9].VAR7 = VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3) payable public {
require(address(this).VAR4 >= VAR3);
require(address(this) != VAR2);
require(VAR2.call.value(VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
require(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR2.call.value(msg.value)());
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 VAR3 = 0;
uint256 VAR4 = 0;
function FUN1() public returns (bool) {
uint256 VAR5 = VAR6.VAR7 / (60*60*24*30*3);
if (VAR5 >= VAR4) {
VAR3 = VAR2[msg.sender];
}
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1() {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR3 = VAR2 <= VAR4.VAR5;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint value, bytes VAR3) external {
require(VAR2.call.value(value)(VAR3));
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!VAR2.call.value(VAR3)()) revert();
return true;
}
}
0
---------------------------------
contract VAR1  {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => VAR2) internal VAR3;
struct VAR2 {
uint VAR4;
uint VAR5;
}
function FUN1(address VAR6) public view returns (uint256){
TimeEnvoy storage VAR7 = VAR3[VAR6];
if (VAR8.VAR9 >= VAR7.VAR4) {
return VAR7.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable {
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
}
}
0
---------------------------------
contract VAR1 {
mapping (uint256 => address) public VAR2;
function FUN1() public payable{
if(msg.sender != VAR2[0]){
VAR2[0].call.value(msg.value).FUN2(600000)();
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, uint256 VAR5, bytes VAR6) external onlyOwner returns (bool){
return VAR4.call.value(VAR5)(VAR6);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}
0
---------------------------------
contract VAR1 {
uint256 private VAR2;
function FUN1() public {
require(VAR2 < VAR3.VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;  
function FUN1() public returns(uint){
VAR2 = VAR3.VAR4;
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = msg.sender;
function FUN1(uint VAR3, address VAR4) payable {
if(msg.sender != address(this)) throw;
if(!VAR4.call.value(VAR3)()) { throw; }
}
}
0
---------------------------------
contract VAR1 {
function FUN1 () external view returns (uint256) {
return VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1{
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1()  {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
delete VAR2[VAR3];
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;
function FUN1() external returns(bool){
assert(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
function FUN1() external constant returns (uint256) {
if(VAR2 > VAR3.VAR4)
return VAR2;
else
return 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
if(!VAR2.call.value(msg.value)()) revert();
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1 (address VAR2) external constant returns (uint VAR3);
}
contract VAR4 {
uint256 public VAR5;
function FUN2 (address VAR6) external returns (uint256) {
VAR5 = VAR7.VAR8;
return VAR5;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 1499436000;
address public VAR3;
function FUN1() {
if (VAR4.VAR5 < VAR2) throw;
if (!VAR3.call.value(this.VAR6)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
bool VAR4 = msg.sender.call.value(VAR3)();
require(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint VAR2 = 0;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR3 >= VAR4.VAR5);
VAR2 = VAR3;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint VAR2;
function FUN1() public returns (uint VAR3) {
while (VAR2 > VAR4.VAR5) {
msg.sender.call.value(VAR3);
}
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
enum VAR3 { VAR4, VAR5}
function FUN1() public constant returns (VAR3) {
if (VAR6.VAR7 < VAR2) {
return VAR3.VAR4;
} else {
return VAR3.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint64 VAR2;
function FUN1() public {
uint64 VAR3 = FUN2(VAR4.VAR5);
require(VAR3 >= VAR2);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {  
uint VAR3;
}
mapping(address => VAR2) VAR4;
function FUN1(address VAR5, uint VAR6) public constant returns (bool VAR7) {
if (VAR8.VAR9 < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable returns (bool){
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public {
uint256 VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
require(VAR3.call.value(VAR4)());
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public returns (uint256) {
uint64 VAR3 = FUN2(VAR4.VAR3);
require(VAR3 >= 1546300801);
return 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address=>uint256) public VAR2;
function FUN1() public payable {
if(VAR2[msg.sender] != 0) {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public constant returns(uint256) {
assert(VAR3.VAR4 >= VAR2);
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint64 public VAR2 = 0;
function FUN1(uint256 VAR3) private {
if (VAR4.VAR5 <= VAR2) {
require(VAR3 == 0.64 VAR6);
}
else {
require(VAR3 == 0.99 VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() public{
assert(msg.sender.call.value(VAR2[msg.sender])()) ;
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
interface VAR1 {
function FUN1() public view returns(uint256);
function FUN2() public view returns(uint256);
}
contract VAR2 {
FoMo3DlongInterface VAR3;
function FUN3() public  {
if (VAR3.FUN2() > 50) { revert(); }
address(VAR3).call.value(VAR3.FUN1())();
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public;
}
contract VAR2 {
mapping (address => uint) VAR3;
function FUN2() public payable {
fomo3d VAR4 = FUN3(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR3[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
contract VAR1{
mapping (address => uint256) public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5,uint256 VAR6) onlyOwner public returns (bool) {
if(VAR6 > VAR7.VAR8) {
VAR2[VAR5] = VAR6;
return true;
}
return false;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
}
Proposal public VAR4;
function FUN1(uint256 VAR5) external {
VAR4.VAR3 = VAR6.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) constant public returns(uint) {
return uint(FUN2(VAR3.VAR4, VAR3.VAR5)) ^ VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256[2] internal VAR2;
address VAR3 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR4) public returns (bool) {
uint256 VAR5 = VAR6.VAR7;
if (msg.sender == VAR3) {
VAR2[0] = VAR5;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public constant VAR2 = 1559347200;
function FUN1() constant returns (bool) {
return (VAR3.VAR4 < VAR2);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
assert(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
uint256 VAR4;
}
Proposal public VAR5;
bool public VAR6 = false;
function FUN1(uint256 VAR4) external {
VAR5.VAR3 = VAR7.VAR3;
VAR5.VAR4 = VAR4;
VAR6 = true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
function FUN1() public payable {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.call.value(VAR3);
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public returns (bool) {
require(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) VAR2;
uint constant VAR3 = 1596067200;
function FUN1() {
if (VAR4.VAR5 < VAR3) throw;
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(address => uint256) public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1() public onlyOwner returns (uint256) {
uint64 VAR5 = FUN2(VAR6.VAR5);
require(VAR5 >= 1546300801);
return VAR3[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
contract VAR1 {
bool public VAR2;
address VAR3;
function FUN1() public payable {
if (!VAR3.call.value(msg.value)()) {
VAR2 = false;
} else {
VAR2 = true;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1(uint256 VAR3) external returns (bool){
require(VAR4.VAR5 > VAR2);           
require(VAR3 > 0);
return true;
}
}
0
---------------------------------
contract VAR1{
mapping (address => mapping (address => uint)) public VAR2;
function FUN1(uint VAR3) {
if (VAR2[0][msg.sender] < VAR3) throw;
if (!msg.sender.call.value(VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint VAR3;
}
mapping (address => VAR2) VAR4;
function FUN1() {
require(VAR4[msg.sender].VAR3 < VAR5.VAR6);
VAR4[msg.sender].VAR3 = 0;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1() private view returns(bool) {
uint256 VAR3 = uint256(FUN2(VAR4.FUN3((VAR5.VAR6) / VAR7)));
if(VAR3 < VAR2)
return true;
else
return false;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 10;
function FUN1(uint256 VAR3) public returns (uint) {
if(VAR2 > 1) {
require(VAR2 == 1);
} else {
VAR2 = VAR4.VAR5;
}
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1533686401;
function FUN1() public payable returns (bool VAR3) {
assert(VAR4.VAR5 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1() external onlyOwner returns (uint) {
uint VAR4 = VAR5.VAR6;
return VAR4;
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public payable {
if(msg.value > 1 VAR2) {
msg.sender.call.value(this.VAR3);
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4, bytes VAR5) external payable returns (bool) {
return VAR2.call.value(VAR3).FUN2(VAR4)(VAR5);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) public view returns (uint256) {
Vesting storage VAR6 = VAR4[VAR5];
if (VAR7.VAR8 < VAR6.VAR3) {
return VAR7.VAR8;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
if (!VAR2.call.value(this.VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2 = msg.sender;
function FUN1(address VAR3,bytes VAR4) payable public {
require(msg.sender == VAR2);
VAR3.call.value(msg.value)(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1514764800;
function FUN1() public returns (uint16) {
if (VAR3.VAR4 < VAR2)
return 1000;
return 500;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (uint256) {
if (VAR3.VAR4 < VAR2) {
return VAR2;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if(!VAR4.FUN3(msg.VAR5)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2(bytes VAR6) public {
require(VAR2.FUN3(VAR6));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2 == msg.sender);
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(!VAR2.FUN2(msg.VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
if (msg.sender != VAR3) { throw; }
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR6)) throw;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external returns (bool VAR3) {
VAR3 = VAR2.FUN2(bytes4(FUN3("")), this); 
return VAR3;
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
switch VAR3
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
FUN3(0, 0, VAR6)
}
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) external {
bytes memory VAR3 = msg.VAR3;
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() external payable {
address  VAR2;
VAR3 {
let VAR4 := FUN2(FUN3(0), VAR2, 0, VAR5, 0, 0)
switch VAR4
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
1
---------------------------------
contract VAR1 {
mapping(bytes4 => address) public VAR2;
function FUN1() {
if (!VAR2[msg.VAR3].FUN2(msg.VAR4)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {   
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
let VAR5 := FUN3(VAR6, VAR2, VAR4, VAR7, VAR4, 0)
switch VAR5
case 0 { revert(0, 0) }
default { return(VAR4, 0) }
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
FUN3(VAR4, 0, VAR5)
let VAR6 := FUN4(VAR7, VAR2, VAR4, VAR5, VAR4, 0)
}
}
}
1
---------------------------------
contract VAR1{
mapping(uint => address) VAR2;
function FUN1(uint VAR3, bytes32 VAR4) public {
VAR2[VAR3].FUN2(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external payable{
require(VAR2.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) internal {  
require(VAR2.FUN2(0xc4d66de8, VAR2), "");
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
let VAR10 := FUN2(0x40)
switch VAR8
case 0 {
revert(VAR10, 0)
}
default {
return (VAR10, VAR11)
}
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool) {
return VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
modifier onlyOwner{
require(VAR2 == msg.sender);
VAR3;
}
function FUN1(address VAR4) external onlyOwner {
VAR5 {
FUN2(0, 0, FUN3())
let VAR6 := FUN4(FUN5(0), VAR4, 0, VAR7, 0, 0)
FUN6(0, 0, VAR8)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external payable{
VAR2 = VAR3;
VAR2.FUN2(msg.VAR4);
}
}
1
---------------------------------
contract VAR1 {
enum VAR2 { VAR3 }
function FUN1(address VAR4, HowToCall VAR5, bytes VAR6) public returns (bool VAR7) {
if (VAR5 == VAR2.VAR3) {
VAR7 = VAR4.FUN2(VAR6);
}
return VAR7;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) payable public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 { 
address VAR2;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool VAR3) {
if(VAR2.FUN2(bytes4(FUN3("")), VAR2)) {
VAR3 = true;
} else {
VAR3 = false;
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
function FUN1(address VAR4) public {
require(msg.sender == VAR3);
VAR2 = VAR4;
}
function FUN2(bytes VAR5) public {
require(VAR2.FUN3(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) external returns (bool VAR4) {
if (msg.sender != VAR2) {
return false;
}
if (!address(this).FUN2(VAR3)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) public {
uint256 VAR3 = 3 * 32;
uint256 VAR4 = 4 + VAR3;
bytes memory VAR5 = VAR6 bytes(VAR4);
require(VAR2.FUN2(VAR5));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) public {
require(VAR2 != address(0)); 
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR3 = VAR5;
}
function FUN2() public payable {
if(!VAR3.FUN3(msg.VAR6)) revert();
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool){
bytes4 VAR3 = bytes4(FUN2(""));
return VAR2.FUN3(VAR3, 2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.VAR2.VAR3 > 0)
msg.sender.FUN2(msg.VAR2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1{
mapping(address => uint) VAR2;
function transfer(address VAR3) public {
require(VAR2[VAR3] >= msg.value);
VAR3.FUN1(msg.value);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3) public returns(bytes32 VAR4) {
bool VAR5;
address VAR6 = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
VAR4 = bytes32(0x00);
VAR7 {
VAR5 := FUN2(FUN3(FUN4(VAR8, 10000), VAR6, VAR2, VAR3, VAR4, 0x20))
}
require(!VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1{
function FUN1(address VAR2, bytes memory VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(!VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner returns (bool VAR6) {
return VAR4.FUN2(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
VAR2.FUN2(bytes4(FUN3("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) {
VAR2.VAR5.FUN2(VAR3)(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
if( !VAR2.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
1
---------------------------------
contract VAR1 {
address VAR2 = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;
uint VAR3 = 1111;
function FUN1() payable public {
if(msg.value > VAR3) {
VAR2.FUN2(bytes4(FUN3("")));
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;  
address public VAR3;
uint256 public VAR4 = 10;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN1(address VAR6) payable onlyOwner {
VAR3 = VAR6;
}
function FUN2(address VAR7) payable {
VAR7 = VAR3;
if(msg.value > VAR4) {          
VAR7.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
bytes4 constant VAR3 = bytes4(FUN1(""));
function FUN2(uint VAR4) public {
VAR2.FUN3(VAR3, VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3)  {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address sender, uint value) {
if (sender != 0) {
sender.FUN2(value);
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) {
if (VAR3=='') { throw; }
if (!VAR2.FUN2(VAR3)){ throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) public {
if (!address(this).FUN2(0x21835af6, VAR2 - 1)) throw;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, address VAR4) external returns(uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR2, VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
VAR3 {
let VAR4 := FUN2(VAR5, VAR2, 0, VAR6, 0, 0)
FUN3(0, 0, VAR7)
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
uint public VAR3;
uint public VAR4;
bytes4 constant VAR5 = bytes4(FUN1(""));
function FUN2() {
VAR4 += 1;
require(VAR2.FUN3(VAR5, VAR4));
msg.sender.transfer(VAR3 * 1 VAR6);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public payable {
VAR2.FUN2(VAR4.FUN3("", VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public {
if (! VAR2.FUN2(bytes4(FUN3("")), VAR3)) revert();
}
}
1
---------------------------------
contract VAR1 {
mapping (address => address) private VAR2;
modifier onlyOwner(){
require(VAR2[address(this)] != 0);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR2[address(this)] = VAR4;
}
function FUN2(address VAR5) public {
VAR2[VAR5] = VAR2[address(this)];
VAR2[VAR5].FUN3(msg.VAR6);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bool VAR5) external onlyOwner {
if (VAR5) {
bytes memory VAR6 = VAR7.FUN2(0x4a99e3a1, VAR4);
VAR4.FUN3(VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
bytes4 constant VAR2 = bytes4(FUN1(""));
function FUN2(address VAR3, uint VAR4) {
VAR3.FUN3(VAR2, VAR4);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
}
function FUN2() public {
VAR2.FUN3(bytes4(FUN4("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public returns (uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2 == msg.sender);
VAR3 = VAR4;
}
function FUN2() external {
bytes memory VAR5 = msg.VAR5;
VAR3.FUN3(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
if(!VAR4.FUN2(msg.VAR5)) { throw; }
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) public onlyOwner {
require(VAR4.FUN2(msg.VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) {
require(VAR3 == msg.sender);
require(VAR3.FUN2(msg.VAR4));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) public {
require(msg.sender==VAR3);
VAR2 = VAR4;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR5)) throw;
}
}
0
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external returns (bool VAR4) {
require(msg.sender==VAR2);
VAR4 = VAR3.FUN2(bytes4(FUN3("")), this); 
return VAR4;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3) external {
require(VAR2==msg.sender);
bytes memory VAR4 = msg.VAR4;
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR4.FUN2(msg.VAR5);       
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x29999;
function FUN1(address VAR3) external {
require(VAR2 == msg.sender);
require(VAR3.FUN2(bytes4(FUN3(""))));
}
}
0
---------------------------------
contract VAR1 {   
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3=VAR4;
}
function FUN2(uint256 VAR5, uint256 VAR6) public {
VAR3.FUN3(VAR7.FUN4("", VAR5, VAR6));
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4)external payable onlyOwner {
require(VAR4.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(uint=>address) VAR3;
function FUN1(uint VAR4, address VAR5) {
require(VAR2==msg.sender);
VAR3[VAR4]=VAR5;
}
function FUN2(uint VAR6, bytes32 VAR7) public {
VAR3[VAR6].FUN3(VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner{
require(VAR2==msg.sender);
VAR3;
}
function FUN1() public onlyOwner {
address VAR4;
bytes memory VAR5 = msg.VAR6;
VAR7 {
let VAR8 := FUN2(VAR5)
let VAR9 := FUN3(VAR5, 0x20)
let VAR10 := FUN4(VAR11, VAR4, VAR9, VAR8, 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns (bool) {
return VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
enum VAR3 { VAR4, VAR5 }
function FUN1(address VAR6, HowToCall VAR7, bytes VAR8) public returns (bool VAR9) {
require(VAR2==msg.sender);
if (VAR7 == VAR3.VAR5) {
VAR9 = VAR6.FUN2(VAR8);
}
return VAR9;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) payable public onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) public returns (bool VAR4) {
require(VAR2==msg.sender);
if(VAR3.FUN2(bytes4(FUN3("")), VAR3)) {
VAR4 = true;
} else {
VAR4 = false;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes VAR4) public {
require(VAR2==msg.sender);
VAR5 {
let VAR6 := FUN2(FUN3(VAR7, 10000), VAR3, FUN4(VAR4, 0x20), FUN5(VAR4), 0, 0)
switch VAR6
case 0 { revert(0, VAR8) }
default { return(0, VAR8) }
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner {
VAR6 {
let VAR7 := FUN2(FUN3(VAR8, 10000), VAR4, FUN4(VAR5, 0x20), FUN5(VAR5), 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes VAR2) external returns (bool VAR3) {
if (!address(this).FUN2(VAR2)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes32 VAR5) public onlyOwner {
require(VAR4.FUN2(VAR5));
} 
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public payable {
require(VAR2==msg.sender);
if(!VAR3.FUN2(msg.VAR4)) revert();
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public returns (bool){
require(VAR2==msg.sender);
bytes4 VAR4 = bytes4(FUN2(""));
return VAR3.FUN3(VAR4, 2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(msg.sender==VAR2);
VAR3 = VAR4;
}
function FUN2() public returns (bool) {
bytes4 VAR5 = bytes4(FUN3(""));
return VAR3.FUN4(VAR5,2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
require(VAR2==msg.sender);
if (msg.VAR4.VAR5 > 0)
VAR3.FUN2(msg.VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function transfer(address VAR3) public {
require(VAR2==msg.sender);
if (msg.value > 0){
VAR3.FUN1(msg.value);
} else {
revert();
}
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2= 1000000000000000001;
function FUN1(address VAR3) payable public {
if(msg.value > VAR2){
VAR3.FUN2(bytes4(FUN3("")));
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) external onlyOwner returns (bool VAR6){
if (VAR4.FUN2(VAR5)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,bytes32 VAR3) public {
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public payable returns(bool){
if(!VAR2.FUN2(msg.VAR3)){
return false;
}
else{
return true;
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) payable onlyOwner {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN2(msg.VAR5);
}
}
0
---------------------------------
contract VAR1 {
function transfer(address VAR2) public {
if (msg.value > 0) {
VAR2.FUN1(msg.value);
} else {
revert();
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3, uint VAR4) {
require(VAR2==msg.sender);
VAR3.FUN2(bytes4(FUN3("")), VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3,uint256 VAR4, uint256 VAR5, uint256 VAR6, uint256 VAR7) public returns (bool VAR8) {
require(VAR2==msg.sender);
return VAR3.FUN2(bytes4(FUN3("")), VAR4, VAR5, VAR6, VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
require(msg.sender==VAR2);
if(!VAR3.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
uint256 public VAR4 = 111111;
function FUN1(address VAR5) payable {
require(VAR2==msg.sender);
VAR3 = VAR5;
}
function FUN2() payable {
if(msg.value > VAR4) {          
VAR3.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes memory VAR4) public payable {
require(VAR2==msg.sender);
if(VAR4.VAR5 > 0) {
bool VAR6 = VAR3.FUN2(VAR4);
require(VAR6);
}
}  
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes VAR5) onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2==msg.sender);
if (VAR4=='') { throw; }
if (!VAR3.FUN2(VAR4)){ throw; }
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3 = VAR4;
}
function FUN2() public {
VAR3.FUN3(bytes4(FUN4("")));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
require(VAR4.FUN3(msg.VAR5));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN3(msg.VAR5);
}
}
1
---------------------------------
contract VAR1  {
uint64 public VAR2;
function FUN1() payable public {
if (VAR2 > 1514764800) {
require(VAR2 > VAR3.VAR4);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => bool) VAR2;
mapping (address => uint256) public VAR3;
mapping (address => uint256) public VAR4;
function FUN1(address VAR5) external returns (bool){
require(VAR6.VAR7 >= VAR4[VAR5]);
VAR3[VAR5] = 0;
VAR4[VAR5] = 0;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1(uint256 VAR3) private returns(bool) {
if (VAR2 < VAR3) {
uint256 VAR4 = uint256(FUN2(VAR5.FUN3((VAR6.VAR7))));
return VAR4 > 0;
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns(bool) {
require(VAR4.VAR5 > 1601510400);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint constant VAR2 = 1514402746;
function FUN1(address VAR3) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (VAR4.VAR5 > VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => bool) VAR2;
uint256 public VAR3;
function FUN1(address VAR4) external {
VAR2[VAR4] = true;
VAR3 = VAR5.VAR6;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public payable returns (bool) {
require(VAR2.call.value(msg.value)(VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3, address VAR4) public {
VAR4.call.value(VAR3)(VAR2);
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2;
function FUN1() internal view returns (bool) {
bool VAR3 = VAR4.VAR5 <= VAR2;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint) {
require(VAR4.VAR5 > VAR2);
require(VAR3 > 0);
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) external {
require((VAR6.VAR7 >= VAR4[VAR5].VAR3));
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 public VAR3;
function FUN1 () external {
uint256 VAR4 = uint256(VAR5.VAR6);
require (VAR4 > VAR3);
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) VAR2;
function FUN1() public returns (bool) {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR3)()) {
return true;
} else {
VAR2[msg.sender] = VAR3;
return false;
}
}
}
0
---------------------------------
contract VAR1 {
enum VAR2 {VAR3}
struct VAR4 {
uint256 VAR5;
bool VAR6;     
States VAR7;
}
mapping(address => VAR4) public VAR8;
function FUN1(address VAR9) external {
require(VAR10.VAR11 >= VAR8[VAR9].VAR5);
VAR8[VAR9].VAR7 = VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3) payable public {
require(address(this).VAR4 >= VAR3);
require(address(this) != VAR2);
require(VAR2.call.value(VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
require(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR2.call.value(msg.value)());
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 VAR3 = 0;
uint256 VAR4 = 0;
function FUN1() public returns (bool) {
uint256 VAR5 = VAR6.VAR7 / (60*60*24*30*3);
if (VAR5 >= VAR4) {
VAR3 = VAR2[msg.sender];
}
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1() {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR3 = VAR2 <= VAR4.VAR5;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint value, bytes VAR3) external {
require(VAR2.call.value(value)(VAR3));
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!VAR2.call.value(VAR3)()) revert();
return true;
}
}
0
---------------------------------
contract VAR1  {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => VAR2) internal VAR3;
struct VAR2 {
uint VAR4;
uint VAR5;
}
function FUN1(address VAR6) public view returns (uint256){
TimeEnvoy storage VAR7 = VAR3[VAR6];
if (VAR8.VAR9 >= VAR7.VAR4) {
return VAR7.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable {
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
}
}
0
---------------------------------
contract VAR1 {
mapping (uint256 => address) public VAR2;
function FUN1() public payable{
if(msg.sender != VAR2[0]){
VAR2[0].call.value(msg.value).FUN2(600000)();
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, uint256 VAR5, bytes VAR6) external onlyOwner returns (bool){
return VAR4.call.value(VAR5)(VAR6);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}
0
---------------------------------
contract VAR1 {
uint256 private VAR2;
function FUN1() public {
require(VAR2 < VAR3.VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;  
function FUN1() public returns(uint){
VAR2 = VAR3.VAR4;
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = msg.sender;
function FUN1(uint VAR3, address VAR4) payable {
if(msg.sender != address(this)) throw;
if(!VAR4.call.value(VAR3)()) { throw; }
}
}
0
---------------------------------
contract VAR1 {
function FUN1 () external view returns (uint256) {
return VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1{
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1()  {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
delete VAR2[VAR3];
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;
function FUN1() external returns(bool){
assert(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
function FUN1() external constant returns (uint256) {
if(VAR2 > VAR3.VAR4)
return VAR2;
else
return 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
if(!VAR2.call.value(msg.value)()) revert();
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1 (address VAR2) external constant returns (uint VAR3);
}
contract VAR4 {
uint256 public VAR5;
function FUN2 (address VAR6) external returns (uint256) {
VAR5 = VAR7.VAR8;
return VAR5;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 1499436000;
address public VAR3;
function FUN1() {
if (VAR4.VAR5 < VAR2) throw;
if (!VAR3.call.value(this.VAR6)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
bool VAR4 = msg.sender.call.value(VAR3)();
require(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint VAR2 = 0;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR3 >= VAR4.VAR5);
VAR2 = VAR3;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint VAR2;
function FUN1() public returns (uint VAR3) {
while (VAR2 > VAR4.VAR5) {
msg.sender.call.value(VAR3);
}
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
enum VAR3 { VAR4, VAR5}
function FUN1() public constant returns (VAR3) {
if (VAR6.VAR7 < VAR2) {
return VAR3.VAR4;
} else {
return VAR3.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint64 VAR2;
function FUN1() public {
uint64 VAR3 = FUN2(VAR4.VAR5);
require(VAR3 >= VAR2);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {  
uint VAR3;
}
mapping(address => VAR2) VAR4;
function FUN1(address VAR5, uint VAR6) public constant returns (bool VAR7) {
if (VAR8.VAR9 < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable returns (bool){
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public {
uint256 VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
require(VAR3.call.value(VAR4)());
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public returns (uint256) {
uint64 VAR3 = FUN2(VAR4.VAR3);
require(VAR3 >= 1546300801);
return 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address=>uint256) public VAR2;
function FUN1() public payable {
if(VAR2[msg.sender] != 0) {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public constant returns(uint256) {
assert(VAR3.VAR4 >= VAR2);
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint64 public VAR2 = 0;
function FUN1(uint256 VAR3) private {
if (VAR4.VAR5 <= VAR2) {
require(VAR3 == 0.64 VAR6);
}
else {
require(VAR3 == 0.99 VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() public{
assert(msg.sender.call.value(VAR2[msg.sender])()) ;
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
interface VAR1 {
function FUN1() public view returns(uint256);
function FUN2() public view returns(uint256);
}
contract VAR2 {
FoMo3DlongInterface VAR3;
function FUN3() public  {
if (VAR3.FUN2() > 50) { revert(); }
address(VAR3).call.value(VAR3.FUN1())();
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public;
}
contract VAR2 {
mapping (address => uint) VAR3;
function FUN2() public payable {
fomo3d VAR4 = FUN3(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR3[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
contract VAR1{
mapping (address => uint256) public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5,uint256 VAR6) onlyOwner public returns (bool) {
if(VAR6 > VAR7.VAR8) {
VAR2[VAR5] = VAR6;
return true;
}
return false;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
}
Proposal public VAR4;
function FUN1(uint256 VAR5) external {
VAR4.VAR3 = VAR6.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) constant public returns(uint) {
return uint(FUN2(VAR3.VAR4, VAR3.VAR5)) ^ VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256[2] internal VAR2;
address VAR3 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR4) public returns (bool) {
uint256 VAR5 = VAR6.VAR7;
if (msg.sender == VAR3) {
VAR2[0] = VAR5;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public constant VAR2 = 1559347200;
function FUN1() constant returns (bool) {
return (VAR3.VAR4 < VAR2);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
assert(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
uint256 VAR4;
}
Proposal public VAR5;
bool public VAR6 = false;
function FUN1(uint256 VAR4) external {
VAR5.VAR3 = VAR7.VAR3;
VAR5.VAR4 = VAR4;
VAR6 = true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
function FUN1() public payable {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.call.value(VAR3);
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public returns (bool) {
require(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) VAR2;
uint constant VAR3 = 1596067200;
function FUN1() {
if (VAR4.VAR5 < VAR3) throw;
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(address => uint256) public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1() public onlyOwner returns (uint256) {
uint64 VAR5 = FUN2(VAR6.VAR5);
require(VAR5 >= 1546300801);
return VAR3[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
contract VAR1 {
bool public VAR2;
address VAR3;
function FUN1() public payable {
if (!VAR3.call.value(msg.value)()) {
VAR2 = false;
} else {
VAR2 = true;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1(uint256 VAR3) external returns (bool){
require(VAR4.VAR5 > VAR2);           
require(VAR3 > 0);
return true;
}
}
0
---------------------------------
contract VAR1{
mapping (address => mapping (address => uint)) public VAR2;
function FUN1(uint VAR3) {
if (VAR2[0][msg.sender] < VAR3) throw;
if (!msg.sender.call.value(VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint VAR3;
}
mapping (address => VAR2) VAR4;
function FUN1() {
require(VAR4[msg.sender].VAR3 < VAR5.VAR6);
VAR4[msg.sender].VAR3 = 0;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1() private view returns(bool) {
uint256 VAR3 = uint256(FUN2(VAR4.FUN3((VAR5.VAR6) / VAR7)));
if(VAR3 < VAR2)
return true;
else
return false;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 10;
function FUN1(uint256 VAR3) public returns (uint) {
if(VAR2 > 1) {
require(VAR2 == 1);
} else {
VAR2 = VAR4.VAR5;
}
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1533686401;
function FUN1() public payable returns (bool VAR3) {
assert(VAR4.VAR5 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1() external onlyOwner returns (uint) {
uint VAR4 = VAR5.VAR6;
return VAR4;
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public payable {
if(msg.value > 1 VAR2) {
msg.sender.call.value(this.VAR3);
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4, bytes VAR5) external payable returns (bool) {
return VAR2.call.value(VAR3).FUN2(VAR4)(VAR5);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) public view returns (uint256) {
Vesting storage VAR6 = VAR4[VAR5];
if (VAR7.VAR8 < VAR6.VAR3) {
return VAR7.VAR8;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
if (!VAR2.call.value(this.VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2 = msg.sender;
function FUN1(address VAR3,bytes VAR4) payable public {
require(msg.sender == VAR2);
VAR3.call.value(msg.value)(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1514764800;
function FUN1() public returns (uint16) {
if (VAR3.VAR4 < VAR2)
return 1000;
return 500;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (uint256) {
if (VAR3.VAR4 < VAR2) {
return VAR2;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if(!VAR4.FUN3(msg.VAR5)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2(bytes VAR6) public {
require(VAR2.FUN3(VAR6));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2 == msg.sender);
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(!VAR2.FUN2(msg.VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
if (msg.sender != VAR3) { throw; }
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR6)) throw;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external returns (bool VAR3) {
VAR3 = VAR2.FUN2(bytes4(FUN3("")), this); 
return VAR3;
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
switch VAR3
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
FUN3(0, 0, VAR6)
}
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) external {
bytes memory VAR3 = msg.VAR3;
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() external payable {
address  VAR2;
VAR3 {
let VAR4 := FUN2(FUN3(0), VAR2, 0, VAR5, 0, 0)
switch VAR4
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
1
---------------------------------
contract VAR1 {
mapping(bytes4 => address) public VAR2;
function FUN1() {
if (!VAR2[msg.VAR3].FUN2(msg.VAR4)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {   
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
let VAR5 := FUN3(VAR6, VAR2, VAR4, VAR7, VAR4, 0)
switch VAR5
case 0 { revert(0, 0) }
default { return(VAR4, 0) }
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
FUN3(VAR4, 0, VAR5)
let VAR6 := FUN4(VAR7, VAR2, VAR4, VAR5, VAR4, 0)
}
}
}
1
---------------------------------
contract VAR1{
mapping(uint => address) VAR2;
function FUN1(uint VAR3, bytes32 VAR4) public {
VAR2[VAR3].FUN2(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external payable{
require(VAR2.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) internal {  
require(VAR2.FUN2(0xc4d66de8, VAR2), "");
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
let VAR10 := FUN2(0x40)
switch VAR8
case 0 {
revert(VAR10, 0)
}
default {
return (VAR10, VAR11)
}
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool) {
return VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
modifier onlyOwner{
require(VAR2 == msg.sender);
VAR3;
}
function FUN1(address VAR4) external onlyOwner {
VAR5 {
FUN2(0, 0, FUN3())
let VAR6 := FUN4(FUN5(0), VAR4, 0, VAR7, 0, 0)
FUN6(0, 0, VAR8)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external payable{
VAR2 = VAR3;
VAR2.FUN2(msg.VAR4);
}
}
1
---------------------------------
contract VAR1 {
enum VAR2 { VAR3 }
function FUN1(address VAR4, HowToCall VAR5, bytes VAR6) public returns (bool VAR7) {
if (VAR5 == VAR2.VAR3) {
VAR7 = VAR4.FUN2(VAR6);
}
return VAR7;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) payable public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 { 
address VAR2;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool VAR3) {
if(VAR2.FUN2(bytes4(FUN3("")), VAR2)) {
VAR3 = true;
} else {
VAR3 = false;
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
function FUN1(address VAR4) public {
require(msg.sender == VAR3);
VAR2 = VAR4;
}
function FUN2(bytes VAR5) public {
require(VAR2.FUN3(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) external returns (bool VAR4) {
if (msg.sender != VAR2) {
return false;
}
if (!address(this).FUN2(VAR3)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) public {
uint256 VAR3 = 3 * 32;
uint256 VAR4 = 4 + VAR3;
bytes memory VAR5 = VAR6 bytes(VAR4);
require(VAR2.FUN2(VAR5));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) public {
require(VAR2 != address(0)); 
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR3 = VAR5;
}
function FUN2() public payable {
if(!VAR3.FUN3(msg.VAR6)) revert();
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool){
bytes4 VAR3 = bytes4(FUN2(""));
return VAR2.FUN3(VAR3, 2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.VAR2.VAR3 > 0)
msg.sender.FUN2(msg.VAR2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1{
mapping(address => uint) VAR2;
function transfer(address VAR3) public {
require(VAR2[VAR3] >= msg.value);
VAR3.FUN1(msg.value);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3) public returns(bytes32 VAR4) {
bool VAR5;
address VAR6 = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
VAR4 = bytes32(0x00);
VAR7 {
VAR5 := FUN2(FUN3(FUN4(VAR8, 10000), VAR6, VAR2, VAR3, VAR4, 0x20))
}
require(!VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1{
function FUN1(address VAR2, bytes memory VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(!VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner returns (bool VAR6) {
return VAR4.FUN2(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
VAR2.FUN2(bytes4(FUN3("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) {
VAR2.VAR5.FUN2(VAR3)(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
if( !VAR2.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
1
---------------------------------
contract VAR1 {
address VAR2 = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;
uint VAR3 = 1111;
function FUN1() payable public {
if(msg.value > VAR3) {
VAR2.FUN2(bytes4(FUN3("")));
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;  
address public VAR3;
uint256 public VAR4 = 10;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN1(address VAR6) payable onlyOwner {
VAR3 = VAR6;
}
function FUN2(address VAR7) payable {
VAR7 = VAR3;
if(msg.value > VAR4) {          
VAR7.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
bytes4 constant VAR3 = bytes4(FUN1(""));
function FUN2(uint VAR4) public {
VAR2.FUN3(VAR3, VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3)  {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address sender, uint value) {
if (sender != 0) {
sender.FUN2(value);
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) {
if (VAR3=='') { throw; }
if (!VAR2.FUN2(VAR3)){ throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) public {
if (!address(this).FUN2(0x21835af6, VAR2 - 1)) throw;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, address VAR4) external returns(uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR2, VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
VAR3 {
let VAR4 := FUN2(VAR5, VAR2, 0, VAR6, 0, 0)
FUN3(0, 0, VAR7)
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
uint public VAR3;
uint public VAR4;
bytes4 constant VAR5 = bytes4(FUN1(""));
function FUN2() {
VAR4 += 1;
require(VAR2.FUN3(VAR5, VAR4));
msg.sender.transfer(VAR3 * 1 VAR6);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public payable {
VAR2.FUN2(VAR4.FUN3("", VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public {
if (! VAR2.FUN2(bytes4(FUN3("")), VAR3)) revert();
}
}
1
---------------------------------
contract VAR1 {
mapping (address => address) private VAR2;
modifier onlyOwner(){
require(VAR2[address(this)] != 0);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR2[address(this)] = VAR4;
}
function FUN2(address VAR5) public {
VAR2[VAR5] = VAR2[address(this)];
VAR2[VAR5].FUN3(msg.VAR6);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bool VAR5) external onlyOwner {
if (VAR5) {
bytes memory VAR6 = VAR7.FUN2(0x4a99e3a1, VAR4);
VAR4.FUN3(VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
bytes4 constant VAR2 = bytes4(FUN1(""));
function FUN2(address VAR3, uint VAR4) {
VAR3.FUN3(VAR2, VAR4);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
}
function FUN2() public {
VAR2.FUN3(bytes4(FUN4("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public returns (uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2 == msg.sender);
VAR3 = VAR4;
}
function FUN2() external {
bytes memory VAR5 = msg.VAR5;
VAR3.FUN3(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
if(!VAR4.FUN2(msg.VAR5)) { throw; }
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) public onlyOwner {
require(VAR4.FUN2(msg.VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) {
require(VAR3 == msg.sender);
require(VAR3.FUN2(msg.VAR4));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) public {
require(msg.sender==VAR3);
VAR2 = VAR4;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR5)) throw;
}
}
0
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external returns (bool VAR4) {
require(msg.sender==VAR2);
VAR4 = VAR3.FUN2(bytes4(FUN3("")), this); 
return VAR4;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3) external {
require(VAR2==msg.sender);
bytes memory VAR4 = msg.VAR4;
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR4.FUN2(msg.VAR5);       
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x29999;
function FUN1(address VAR3) external {
require(VAR2 == msg.sender);
require(VAR3.FUN2(bytes4(FUN3(""))));
}
}
0
---------------------------------
contract VAR1 {   
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3=VAR4;
}
function FUN2(uint256 VAR5, uint256 VAR6) public {
VAR3.FUN3(VAR7.FUN4("", VAR5, VAR6));
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4)external payable onlyOwner {
require(VAR4.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(uint=>address) VAR3;
function FUN1(uint VAR4, address VAR5) {
require(VAR2==msg.sender);
VAR3[VAR4]=VAR5;
}
function FUN2(uint VAR6, bytes32 VAR7) public {
VAR3[VAR6].FUN3(VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner{
require(VAR2==msg.sender);
VAR3;
}
function FUN1() public onlyOwner {
address VAR4;
bytes memory VAR5 = msg.VAR6;
VAR7 {
let VAR8 := FUN2(VAR5)
let VAR9 := FUN3(VAR5, 0x20)
let VAR10 := FUN4(VAR11, VAR4, VAR9, VAR8, 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns (bool) {
return VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
enum VAR3 { VAR4, VAR5 }
function FUN1(address VAR6, HowToCall VAR7, bytes VAR8) public returns (bool VAR9) {
require(VAR2==msg.sender);
if (VAR7 == VAR3.VAR5) {
VAR9 = VAR6.FUN2(VAR8);
}
return VAR9;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) payable public onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) public returns (bool VAR4) {
require(VAR2==msg.sender);
if(VAR3.FUN2(bytes4(FUN3("")), VAR3)) {
VAR4 = true;
} else {
VAR4 = false;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes VAR4) public {
require(VAR2==msg.sender);
VAR5 {
let VAR6 := FUN2(FUN3(VAR7, 10000), VAR3, FUN4(VAR4, 0x20), FUN5(VAR4), 0, 0)
switch VAR6
case 0 { revert(0, VAR8) }
default { return(0, VAR8) }
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner {
VAR6 {
let VAR7 := FUN2(FUN3(VAR8, 10000), VAR4, FUN4(VAR5, 0x20), FUN5(VAR5), 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes VAR2) external returns (bool VAR3) {
if (!address(this).FUN2(VAR2)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes32 VAR5) public onlyOwner {
require(VAR4.FUN2(VAR5));
} 
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public payable {
require(VAR2==msg.sender);
if(!VAR3.FUN2(msg.VAR4)) revert();
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public returns (bool){
require(VAR2==msg.sender);
bytes4 VAR4 = bytes4(FUN2(""));
return VAR3.FUN3(VAR4, 2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(msg.sender==VAR2);
VAR3 = VAR4;
}
function FUN2() public returns (bool) {
bytes4 VAR5 = bytes4(FUN3(""));
return VAR3.FUN4(VAR5,2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
require(VAR2==msg.sender);
if (msg.VAR4.VAR5 > 0)
VAR3.FUN2(msg.VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function transfer(address VAR3) public {
require(VAR2==msg.sender);
if (msg.value > 0){
VAR3.FUN1(msg.value);
} else {
revert();
}
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2= 1000000000000000001;
function FUN1(address VAR3) payable public {
if(msg.value > VAR2){
VAR3.FUN2(bytes4(FUN3("")));
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) external onlyOwner returns (bool VAR6){
if (VAR4.FUN2(VAR5)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,bytes32 VAR3) public {
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public payable returns(bool){
if(!VAR2.FUN2(msg.VAR3)){
return false;
}
else{
return true;
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) payable onlyOwner {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN2(msg.VAR5);
}
}
0
---------------------------------
contract VAR1 {
function transfer(address VAR2) public {
if (msg.value > 0) {
VAR2.FUN1(msg.value);
} else {
revert();
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3, uint VAR4) {
require(VAR2==msg.sender);
VAR3.FUN2(bytes4(FUN3("")), VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3,uint256 VAR4, uint256 VAR5, uint256 VAR6, uint256 VAR7) public returns (bool VAR8) {
require(VAR2==msg.sender);
return VAR3.FUN2(bytes4(FUN3("")), VAR4, VAR5, VAR6, VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
require(msg.sender==VAR2);
if(!VAR3.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
uint256 public VAR4 = 111111;
function FUN1(address VAR5) payable {
require(VAR2==msg.sender);
VAR3 = VAR5;
}
function FUN2() payable {
if(msg.value > VAR4) {          
VAR3.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes memory VAR4) public payable {
require(VAR2==msg.sender);
if(VAR4.VAR5 > 0) {
bool VAR6 = VAR3.FUN2(VAR4);
require(VAR6);
}
}  
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes VAR5) onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2==msg.sender);
if (VAR4=='') { throw; }
if (!VAR3.FUN2(VAR4)){ throw; }
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3 = VAR4;
}
function FUN2() public {
VAR3.FUN3(bytes4(FUN4("")));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
require(VAR4.FUN3(msg.VAR5));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN3(msg.VAR5);
}
}
1
---------------------------------
contract VAR1  {
uint64 public VAR2;
function FUN1() payable public {
if (VAR2 > 1514764800) {
require(VAR2 > VAR3.VAR4);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => bool) VAR2;
mapping (address => uint256) public VAR3;
mapping (address => uint256) public VAR4;
function FUN1(address VAR5) external returns (bool){
require(VAR6.VAR7 >= VAR4[VAR5]);
VAR3[VAR5] = 0;
VAR4[VAR5] = 0;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1(uint256 VAR3) private returns(bool) {
if (VAR2 < VAR3) {
uint256 VAR4 = uint256(FUN2(VAR5.FUN3((VAR6.VAR7))));
return VAR4 > 0;
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns(bool) {
require(VAR4.VAR5 > 1601510400);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint constant VAR2 = 1514402746;
function FUN1(address VAR3) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (VAR4.VAR5 > VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => bool) VAR2;
uint256 public VAR3;
function FUN1(address VAR4) external {
VAR2[VAR4] = true;
VAR3 = VAR5.VAR6;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public payable returns (bool) {
require(VAR2.call.value(msg.value)(VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3, address VAR4) public {
VAR4.call.value(VAR3)(VAR2);
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2;
function FUN1() internal view returns (bool) {
bool VAR3 = VAR4.VAR5 <= VAR2;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint) {
require(VAR4.VAR5 > VAR2);
require(VAR3 > 0);
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) external {
require((VAR6.VAR7 >= VAR4[VAR5].VAR3));
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 public VAR3;
function FUN1 () external {
uint256 VAR4 = uint256(VAR5.VAR6);
require (VAR4 > VAR3);
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) VAR2;
function FUN1() public returns (bool) {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR3)()) {
return true;
} else {
VAR2[msg.sender] = VAR3;
return false;
}
}
}
0
---------------------------------
contract VAR1 {
enum VAR2 {VAR3}
struct VAR4 {
uint256 VAR5;
bool VAR6;     
States VAR7;
}
mapping(address => VAR4) public VAR8;
function FUN1(address VAR9) external {
require(VAR10.VAR11 >= VAR8[VAR9].VAR5);
VAR8[VAR9].VAR7 = VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3) payable public {
require(address(this).VAR4 >= VAR3);
require(address(this) != VAR2);
require(VAR2.call.value(VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
require(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR2.call.value(msg.value)());
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 VAR3 = 0;
uint256 VAR4 = 0;
function FUN1() public returns (bool) {
uint256 VAR5 = VAR6.VAR7 / (60*60*24*30*3);
if (VAR5 >= VAR4) {
VAR3 = VAR2[msg.sender];
}
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1() {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR3 = VAR2 <= VAR4.VAR5;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint value, bytes VAR3) external {
require(VAR2.call.value(value)(VAR3));
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!VAR2.call.value(VAR3)()) revert();
return true;
}
}
0
---------------------------------
contract VAR1  {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => VAR2) internal VAR3;
struct VAR2 {
uint VAR4;
uint VAR5;
}
function FUN1(address VAR6) public view returns (uint256){
TimeEnvoy storage VAR7 = VAR3[VAR6];
if (VAR8.VAR9 >= VAR7.VAR4) {
return VAR7.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable {
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
}
}
0
---------------------------------
contract VAR1 {
mapping (uint256 => address) public VAR2;
function FUN1() public payable{
if(msg.sender != VAR2[0]){
VAR2[0].call.value(msg.value).FUN2(600000)();
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, uint256 VAR5, bytes VAR6) external onlyOwner returns (bool){
return VAR4.call.value(VAR5)(VAR6);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}
0
---------------------------------
contract VAR1 {
uint256 private VAR2;
function FUN1() public {
require(VAR2 < VAR3.VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;  
function FUN1() public returns(uint){
VAR2 = VAR3.VAR4;
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = msg.sender;
function FUN1(uint VAR3, address VAR4) payable {
if(msg.sender != address(this)) throw;
if(!VAR4.call.value(VAR3)()) { throw; }
}
}
0
---------------------------------
contract VAR1 {
function FUN1 () external view returns (uint256) {
return VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1{
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1()  {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
delete VAR2[VAR3];
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;
function FUN1() external returns(bool){
assert(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
function FUN1() external constant returns (uint256) {
if(VAR2 > VAR3.VAR4)
return VAR2;
else
return 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
if(!VAR2.call.value(msg.value)()) revert();
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1 (address VAR2) external constant returns (uint VAR3);
}
contract VAR4 {
uint256 public VAR5;
function FUN2 (address VAR6) external returns (uint256) {
VAR5 = VAR7.VAR8;
return VAR5;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 1499436000;
address public VAR3;
function FUN1() {
if (VAR4.VAR5 < VAR2) throw;
if (!VAR3.call.value(this.VAR6)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
bool VAR4 = msg.sender.call.value(VAR3)();
require(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint VAR2 = 0;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR3 >= VAR4.VAR5);
VAR2 = VAR3;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint VAR2;
function FUN1() public returns (uint VAR3) {
while (VAR2 > VAR4.VAR5) {
msg.sender.call.value(VAR3);
}
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
enum VAR3 { VAR4, VAR5}
function FUN1() public constant returns (VAR3) {
if (VAR6.VAR7 < VAR2) {
return VAR3.VAR4;
} else {
return VAR3.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint64 VAR2;
function FUN1() public {
uint64 VAR3 = FUN2(VAR4.VAR5);
require(VAR3 >= VAR2);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {  
uint VAR3;
}
mapping(address => VAR2) VAR4;
function FUN1(address VAR5, uint VAR6) public constant returns (bool VAR7) {
if (VAR8.VAR9 < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable returns (bool){
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public {
uint256 VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
require(VAR3.call.value(VAR4)());
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public returns (uint256) {
uint64 VAR3 = FUN2(VAR4.VAR3);
require(VAR3 >= 1546300801);
return 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address=>uint256) public VAR2;
function FUN1() public payable {
if(VAR2[msg.sender] != 0) {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public constant returns(uint256) {
assert(VAR3.VAR4 >= VAR2);
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint64 public VAR2 = 0;
function FUN1(uint256 VAR3) private {
if (VAR4.VAR5 <= VAR2) {
require(VAR3 == 0.64 VAR6);
}
else {
require(VAR3 == 0.99 VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() public{
assert(msg.sender.call.value(VAR2[msg.sender])()) ;
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
interface VAR1 {
function FUN1() public view returns(uint256);
function FUN2() public view returns(uint256);
}
contract VAR2 {
FoMo3DlongInterface VAR3;
function FUN3() public  {
if (VAR3.FUN2() > 50) { revert(); }
address(VAR3).call.value(VAR3.FUN1())();
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public;
}
contract VAR2 {
mapping (address => uint) VAR3;
function FUN2() public payable {
fomo3d VAR4 = FUN3(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR3[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
contract VAR1{
mapping (address => uint256) public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5,uint256 VAR6) onlyOwner public returns (bool) {
if(VAR6 > VAR7.VAR8) {
VAR2[VAR5] = VAR6;
return true;
}
return false;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
}
Proposal public VAR4;
function FUN1(uint256 VAR5) external {
VAR4.VAR3 = VAR6.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) constant public returns(uint) {
return uint(FUN2(VAR3.VAR4, VAR3.VAR5)) ^ VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256[2] internal VAR2;
address VAR3 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR4) public returns (bool) {
uint256 VAR5 = VAR6.VAR7;
if (msg.sender == VAR3) {
VAR2[0] = VAR5;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public constant VAR2 = 1559347200;
function FUN1() constant returns (bool) {
return (VAR3.VAR4 < VAR2);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
assert(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
uint256 VAR4;
}
Proposal public VAR5;
bool public VAR6 = false;
function FUN1(uint256 VAR4) external {
VAR5.VAR3 = VAR7.VAR3;
VAR5.VAR4 = VAR4;
VAR6 = true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
function FUN1() public payable {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.call.value(VAR3);
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public returns (bool) {
require(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) VAR2;
uint constant VAR3 = 1596067200;
function FUN1() {
if (VAR4.VAR5 < VAR3) throw;
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(address => uint256) public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1() public onlyOwner returns (uint256) {
uint64 VAR5 = FUN2(VAR6.VAR5);
require(VAR5 >= 1546300801);
return VAR3[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
contract VAR1 {
bool public VAR2;
address VAR3;
function FUN1() public payable {
if (!VAR3.call.value(msg.value)()) {
VAR2 = false;
} else {
VAR2 = true;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1(uint256 VAR3) external returns (bool){
require(VAR4.VAR5 > VAR2);           
require(VAR3 > 0);
return true;
}
}
0
---------------------------------
contract VAR1{
mapping (address => mapping (address => uint)) public VAR2;
function FUN1(uint VAR3) {
if (VAR2[0][msg.sender] < VAR3) throw;
if (!msg.sender.call.value(VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint VAR3;
}
mapping (address => VAR2) VAR4;
function FUN1() {
require(VAR4[msg.sender].VAR3 < VAR5.VAR6);
VAR4[msg.sender].VAR3 = 0;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1() private view returns(bool) {
uint256 VAR3 = uint256(FUN2(VAR4.FUN3((VAR5.VAR6) / VAR7)));
if(VAR3 < VAR2)
return true;
else
return false;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 10;
function FUN1(uint256 VAR3) public returns (uint) {
if(VAR2 > 1) {
require(VAR2 == 1);
} else {
VAR2 = VAR4.VAR5;
}
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1533686401;
function FUN1() public payable returns (bool VAR3) {
assert(VAR4.VAR5 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1() external onlyOwner returns (uint) {
uint VAR4 = VAR5.VAR6;
return VAR4;
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public payable {
if(msg.value > 1 VAR2) {
msg.sender.call.value(this.VAR3);
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4, bytes VAR5) external payable returns (bool) {
return VAR2.call.value(VAR3).FUN2(VAR4)(VAR5);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) public view returns (uint256) {
Vesting storage VAR6 = VAR4[VAR5];
if (VAR7.VAR8 < VAR6.VAR3) {
return VAR7.VAR8;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
if (!VAR2.call.value(this.VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2 = msg.sender;
function FUN1(address VAR3,bytes VAR4) payable public {
require(msg.sender == VAR2);
VAR3.call.value(msg.value)(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1514764800;
function FUN1() public returns (uint16) {
if (VAR3.VAR4 < VAR2)
return 1000;
return 500;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (uint256) {
if (VAR3.VAR4 < VAR2) {
return VAR2;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if(!VAR4.FUN3(msg.VAR5)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2(bytes VAR6) public {
require(VAR2.FUN3(VAR6));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2 == msg.sender);
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(!VAR2.FUN2(msg.VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
if (msg.sender != VAR3) { throw; }
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR6)) throw;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external returns (bool VAR3) {
VAR3 = VAR2.FUN2(bytes4(FUN3("")), this); 
return VAR3;
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
switch VAR3
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
FUN3(0, 0, VAR6)
}
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) external {
bytes memory VAR3 = msg.VAR3;
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() external payable {
address  VAR2;
VAR3 {
let VAR4 := FUN2(FUN3(0), VAR2, 0, VAR5, 0, 0)
switch VAR4
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
1
---------------------------------
contract VAR1 {
mapping(bytes4 => address) public VAR2;
function FUN1() {
if (!VAR2[msg.VAR3].FUN2(msg.VAR4)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {   
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
let VAR5 := FUN3(VAR6, VAR2, VAR4, VAR7, VAR4, 0)
switch VAR5
case 0 { revert(0, 0) }
default { return(VAR4, 0) }
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
FUN3(VAR4, 0, VAR5)
let VAR6 := FUN4(VAR7, VAR2, VAR4, VAR5, VAR4, 0)
}
}
}
1
---------------------------------
contract VAR1{
mapping(uint => address) VAR2;
function FUN1(uint VAR3, bytes32 VAR4) public {
VAR2[VAR3].FUN2(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external payable{
require(VAR2.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) internal {  
require(VAR2.FUN2(0xc4d66de8, VAR2), "");
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
let VAR10 := FUN2(0x40)
switch VAR8
case 0 {
revert(VAR10, 0)
}
default {
return (VAR10, VAR11)
}
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool) {
return VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
modifier onlyOwner{
require(VAR2 == msg.sender);
VAR3;
}
function FUN1(address VAR4) external onlyOwner {
VAR5 {
FUN2(0, 0, FUN3())
let VAR6 := FUN4(FUN5(0), VAR4, 0, VAR7, 0, 0)
FUN6(0, 0, VAR8)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external payable{
VAR2 = VAR3;
VAR2.FUN2(msg.VAR4);
}
}
1
---------------------------------
contract VAR1 {
enum VAR2 { VAR3 }
function FUN1(address VAR4, HowToCall VAR5, bytes VAR6) public returns (bool VAR7) {
if (VAR5 == VAR2.VAR3) {
VAR7 = VAR4.FUN2(VAR6);
}
return VAR7;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) payable public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 { 
address VAR2;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool VAR3) {
if(VAR2.FUN2(bytes4(FUN3("")), VAR2)) {
VAR3 = true;
} else {
VAR3 = false;
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
function FUN1(address VAR4) public {
require(msg.sender == VAR3);
VAR2 = VAR4;
}
function FUN2(bytes VAR5) public {
require(VAR2.FUN3(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) external returns (bool VAR4) {
if (msg.sender != VAR2) {
return false;
}
if (!address(this).FUN2(VAR3)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) public {
uint256 VAR3 = 3 * 32;
uint256 VAR4 = 4 + VAR3;
bytes memory VAR5 = VAR6 bytes(VAR4);
require(VAR2.FUN2(VAR5));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) public {
require(VAR2 != address(0)); 
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR3 = VAR5;
}
function FUN2() public payable {
if(!VAR3.FUN3(msg.VAR6)) revert();
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool){
bytes4 VAR3 = bytes4(FUN2(""));
return VAR2.FUN3(VAR3, 2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.VAR2.VAR3 > 0)
msg.sender.FUN2(msg.VAR2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1{
mapping(address => uint) VAR2;
function transfer(address VAR3) public {
require(VAR2[VAR3] >= msg.value);
VAR3.FUN1(msg.value);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3) public returns(bytes32 VAR4) {
bool VAR5;
address VAR6 = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
VAR4 = bytes32(0x00);
VAR7 {
VAR5 := FUN2(FUN3(FUN4(VAR8, 10000), VAR6, VAR2, VAR3, VAR4, 0x20))
}
require(!VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1{
function FUN1(address VAR2, bytes memory VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(!VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner returns (bool VAR6) {
return VAR4.FUN2(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
VAR2.FUN2(bytes4(FUN3("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) {
VAR2.VAR5.FUN2(VAR3)(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
if( !VAR2.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
1
---------------------------------
contract VAR1 {
address VAR2 = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;
uint VAR3 = 1111;
function FUN1() payable public {
if(msg.value > VAR3) {
VAR2.FUN2(bytes4(FUN3("")));
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;  
address public VAR3;
uint256 public VAR4 = 10;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN1(address VAR6) payable onlyOwner {
VAR3 = VAR6;
}
function FUN2(address VAR7) payable {
VAR7 = VAR3;
if(msg.value > VAR4) {          
VAR7.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
bytes4 constant VAR3 = bytes4(FUN1(""));
function FUN2(uint VAR4) public {
VAR2.FUN3(VAR3, VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3)  {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address sender, uint value) {
if (sender != 0) {
sender.FUN2(value);
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) {
if (VAR3=='') { throw; }
if (!VAR2.FUN2(VAR3)){ throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) public {
if (!address(this).FUN2(0x21835af6, VAR2 - 1)) throw;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, address VAR4) external returns(uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR2, VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
VAR3 {
let VAR4 := FUN2(VAR5, VAR2, 0, VAR6, 0, 0)
FUN3(0, 0, VAR7)
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
uint public VAR3;
uint public VAR4;
bytes4 constant VAR5 = bytes4(FUN1(""));
function FUN2() {
VAR4 += 1;
require(VAR2.FUN3(VAR5, VAR4));
msg.sender.transfer(VAR3 * 1 VAR6);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public payable {
VAR2.FUN2(VAR4.FUN3("", VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public {
if (! VAR2.FUN2(bytes4(FUN3("")), VAR3)) revert();
}
}
1
---------------------------------
contract VAR1 {
mapping (address => address) private VAR2;
modifier onlyOwner(){
require(VAR2[address(this)] != 0);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR2[address(this)] = VAR4;
}
function FUN2(address VAR5) public {
VAR2[VAR5] = VAR2[address(this)];
VAR2[VAR5].FUN3(msg.VAR6);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bool VAR5) external onlyOwner {
if (VAR5) {
bytes memory VAR6 = VAR7.FUN2(0x4a99e3a1, VAR4);
VAR4.FUN3(VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
bytes4 constant VAR2 = bytes4(FUN1(""));
function FUN2(address VAR3, uint VAR4) {
VAR3.FUN3(VAR2, VAR4);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
}
function FUN2() public {
VAR2.FUN3(bytes4(FUN4("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public returns (uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2 == msg.sender);
VAR3 = VAR4;
}
function FUN2() external {
bytes memory VAR5 = msg.VAR5;
VAR3.FUN3(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
if(!VAR4.FUN2(msg.VAR5)) { throw; }
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) public onlyOwner {
require(VAR4.FUN2(msg.VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) {
require(VAR3 == msg.sender);
require(VAR3.FUN2(msg.VAR4));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) public {
require(msg.sender==VAR3);
VAR2 = VAR4;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR5)) throw;
}
}
0
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external returns (bool VAR4) {
require(msg.sender==VAR2);
VAR4 = VAR3.FUN2(bytes4(FUN3("")), this); 
return VAR4;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3) external {
require(VAR2==msg.sender);
bytes memory VAR4 = msg.VAR4;
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR4.FUN2(msg.VAR5);       
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x29999;
function FUN1(address VAR3) external {
require(VAR2 == msg.sender);
require(VAR3.FUN2(bytes4(FUN3(""))));
}
}
0
---------------------------------
contract VAR1 {   
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3=VAR4;
}
function FUN2(uint256 VAR5, uint256 VAR6) public {
VAR3.FUN3(VAR7.FUN4("", VAR5, VAR6));
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4)external payable onlyOwner {
require(VAR4.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(uint=>address) VAR3;
function FUN1(uint VAR4, address VAR5) {
require(VAR2==msg.sender);
VAR3[VAR4]=VAR5;
}
function FUN2(uint VAR6, bytes32 VAR7) public {
VAR3[VAR6].FUN3(VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner{
require(VAR2==msg.sender);
VAR3;
}
function FUN1() public onlyOwner {
address VAR4;
bytes memory VAR5 = msg.VAR6;
VAR7 {
let VAR8 := FUN2(VAR5)
let VAR9 := FUN3(VAR5, 0x20)
let VAR10 := FUN4(VAR11, VAR4, VAR9, VAR8, 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns (bool) {
return VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
enum VAR3 { VAR4, VAR5 }
function FUN1(address VAR6, HowToCall VAR7, bytes VAR8) public returns (bool VAR9) {
require(VAR2==msg.sender);
if (VAR7 == VAR3.VAR5) {
VAR9 = VAR6.FUN2(VAR8);
}
return VAR9;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) payable public onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) public returns (bool VAR4) {
require(VAR2==msg.sender);
if(VAR3.FUN2(bytes4(FUN3("")), VAR3)) {
VAR4 = true;
} else {
VAR4 = false;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes VAR4) public {
require(VAR2==msg.sender);
VAR5 {
let VAR6 := FUN2(FUN3(VAR7, 10000), VAR3, FUN4(VAR4, 0x20), FUN5(VAR4), 0, 0)
switch VAR6
case 0 { revert(0, VAR8) }
default { return(0, VAR8) }
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner {
VAR6 {
let VAR7 := FUN2(FUN3(VAR8, 10000), VAR4, FUN4(VAR5, 0x20), FUN5(VAR5), 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes VAR2) external returns (bool VAR3) {
if (!address(this).FUN2(VAR2)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes32 VAR5) public onlyOwner {
require(VAR4.FUN2(VAR5));
} 
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public payable {
require(VAR2==msg.sender);
if(!VAR3.FUN2(msg.VAR4)) revert();
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public returns (bool){
require(VAR2==msg.sender);
bytes4 VAR4 = bytes4(FUN2(""));
return VAR3.FUN3(VAR4, 2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(msg.sender==VAR2);
VAR3 = VAR4;
}
function FUN2() public returns (bool) {
bytes4 VAR5 = bytes4(FUN3(""));
return VAR3.FUN4(VAR5,2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
require(VAR2==msg.sender);
if (msg.VAR4.VAR5 > 0)
VAR3.FUN2(msg.VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function transfer(address VAR3) public {
require(VAR2==msg.sender);
if (msg.value > 0){
VAR3.FUN1(msg.value);
} else {
revert();
}
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2= 1000000000000000001;
function FUN1(address VAR3) payable public {
if(msg.value > VAR2){
VAR3.FUN2(bytes4(FUN3("")));
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) external onlyOwner returns (bool VAR6){
if (VAR4.FUN2(VAR5)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,bytes32 VAR3) public {
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public payable returns(bool){
if(!VAR2.FUN2(msg.VAR3)){
return false;
}
else{
return true;
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) payable onlyOwner {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN2(msg.VAR5);
}
}
0
---------------------------------
contract VAR1 {
function transfer(address VAR2) public {
if (msg.value > 0) {
VAR2.FUN1(msg.value);
} else {
revert();
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3, uint VAR4) {
require(VAR2==msg.sender);
VAR3.FUN2(bytes4(FUN3("")), VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3,uint256 VAR4, uint256 VAR5, uint256 VAR6, uint256 VAR7) public returns (bool VAR8) {
require(VAR2==msg.sender);
return VAR3.FUN2(bytes4(FUN3("")), VAR4, VAR5, VAR6, VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
require(msg.sender==VAR2);
if(!VAR3.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
uint256 public VAR4 = 111111;
function FUN1(address VAR5) payable {
require(VAR2==msg.sender);
VAR3 = VAR5;
}
function FUN2() payable {
if(msg.value > VAR4) {          
VAR3.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes memory VAR4) public payable {
require(VAR2==msg.sender);
if(VAR4.VAR5 > 0) {
bool VAR6 = VAR3.FUN2(VAR4);
require(VAR6);
}
}  
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes VAR5) onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2==msg.sender);
if (VAR4=='') { throw; }
if (!VAR3.FUN2(VAR4)){ throw; }
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3 = VAR4;
}
function FUN2() public {
VAR3.FUN3(bytes4(FUN4("")));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
require(VAR4.FUN3(msg.VAR5));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN3(msg.VAR5);
}
}
1
---------------------------------
contract VAR1  {
uint64 public VAR2;
function FUN1() payable public {
if (VAR2 > 1514764800) {
require(VAR2 > VAR3.VAR4);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => bool) VAR2;
mapping (address => uint256) public VAR3;
mapping (address => uint256) public VAR4;
function FUN1(address VAR5) external returns (bool){
require(VAR6.VAR7 >= VAR4[VAR5]);
VAR3[VAR5] = 0;
VAR4[VAR5] = 0;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1(uint256 VAR3) private returns(bool) {
if (VAR2 < VAR3) {
uint256 VAR4 = uint256(FUN2(VAR5.FUN3((VAR6.VAR7))));
return VAR4 > 0;
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns(bool) {
require(VAR4.VAR5 > 1601510400);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint constant VAR2 = 1514402746;
function FUN1(address VAR3) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (VAR4.VAR5 > VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => bool) VAR2;
uint256 public VAR3;
function FUN1(address VAR4) external {
VAR2[VAR4] = true;
VAR3 = VAR5.VAR6;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public payable returns (bool) {
require(VAR2.call.value(msg.value)(VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3, address VAR4) public {
VAR4.call.value(VAR3)(VAR2);
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2;
function FUN1() internal view returns (bool) {
bool VAR3 = VAR4.VAR5 <= VAR2;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
uint256 public VAR3;
function FUN1() external returns (uint) {
require(VAR4.VAR5 > VAR2);
require(VAR3 > 0);
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) external {
require((VAR6.VAR7 >= VAR4[VAR5].VAR3));
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 public VAR3;
function FUN1 () external {
uint256 VAR4 = uint256(VAR5.VAR6);
require (VAR4 > VAR3);
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) VAR2;
function FUN1() public returns (bool) {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR3)()) {
return true;
} else {
VAR2[msg.sender] = VAR3;
return false;
}
}
}
0
---------------------------------
contract VAR1 {
enum VAR2 {VAR3}
struct VAR4 {
uint256 VAR5;
bool VAR6;     
States VAR7;
}
mapping(address => VAR4) public VAR8;
function FUN1(address VAR9) external {
require(VAR10.VAR11 >= VAR8[VAR9].VAR5);
VAR8[VAR9].VAR7 = VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3) payable public {
require(address(this).VAR4 >= VAR3);
require(address(this) != VAR2);
require(VAR2.call.value(VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
require(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function FUN1() public payable {
require(VAR2.call.value(msg.value)());
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint256) public VAR2;
uint256 VAR3 = 0;
uint256 VAR4 = 0;
function FUN1() public returns (bool) {
uint256 VAR5 = VAR6.VAR7 / (60*60*24*30*3);
if (VAR5 >= VAR4) {
VAR3 = VAR2[msg.sender];
}
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1() {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 1518696000;
function FUN1() internal constant returns (bool) {
bool VAR3 = VAR2 <= VAR4.VAR5;
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint value, bytes VAR3) external {
require(VAR2.call.value(value)(VAR3));
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2, uint VAR3) returns (bool) {
if (!VAR2.call.value(VAR3)()) revert();
return true;
}
}
0
---------------------------------
contract VAR1  {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => VAR2) internal VAR3;
struct VAR2 {
uint VAR4;
uint VAR5;
}
function FUN1(address VAR6) public view returns (uint256){
TimeEnvoy storage VAR7 = VAR3[VAR6];
if (VAR8.VAR9 >= VAR7.VAR4) {
return VAR7.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable {
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
}
}
0
---------------------------------
contract VAR1 {
mapping (uint256 => address) public VAR2;
function FUN1() public payable{
if(msg.sender != VAR2[0]){
VAR2[0].call.value(msg.value).FUN2(600000)();
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, uint256 VAR5, bytes VAR6) external onlyOwner returns (bool){
return VAR4.call.value(VAR5)(VAR6);
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) private VAR2;
function FUN1() external returns (bool VAR3) {
uint256 VAR4 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!msg.sender.call.value(VAR4)()) { throw; }
VAR3 = true;
}
}
0
---------------------------------
contract VAR1 {
uint256 private VAR2;
function FUN1() public {
require(VAR2 < VAR3.VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;  
function FUN1() public returns(uint){
VAR2 = VAR3.VAR4;
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = msg.sender;
function FUN1(uint VAR3, address VAR4) payable {
if(msg.sender != address(this)) throw;
if(!VAR4.call.value(VAR3)()) { throw; }
}
}
0
---------------------------------
contract VAR1 {
function FUN1 () external view returns (uint256) {
return VAR2.VAR3;
}
}
0
---------------------------------
contract VAR1{
mapping(address => uint) public VAR2;
address VAR3 = msg.sender;
function FUN1()  {
if(VAR2[VAR3] == 0) throw;
uint VAR4 = VAR2[VAR3];
delete VAR2[VAR3];
if(!(VAR3.call.value(VAR4)())) throw;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 0;
function FUN1() external returns(bool){
assert(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
function FUN1() external constant returns (uint256) {
if(VAR2 > VAR3.VAR4)
return VAR2;
else
return 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
if(!VAR2.call.value(msg.value)()) revert();
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (bool) {
return VAR3.VAR4 > VAR2;
}
}
0
---------------------------------
contract VAR1 {
function FUN1 (address VAR2) external constant returns (uint VAR3);
}
contract VAR4 {
uint256 public VAR5;
function FUN2 (address VAR6) external returns (uint256) {
VAR5 = VAR7.VAR8;
return VAR5;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 1499436000;
address public VAR3;
function FUN1() {
if (VAR4.VAR5 < VAR2) throw;
if (!VAR3.call.value(this.VAR6)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
bool VAR4 = msg.sender.call.value(VAR3)();
require(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint VAR2 = 0;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR3 >= VAR4.VAR5);
VAR2 = VAR3;
return true;
}
}
0
---------------------------------
contract VAR1 {
uint VAR2;
function FUN1() public returns (uint VAR3) {
while (VAR2 > VAR4.VAR5) {
msg.sender.call.value(VAR3);
}
return VAR3;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
enum VAR3 { VAR4, VAR5}
function FUN1() public constant returns (VAR3) {
if (VAR6.VAR7 < VAR2) {
return VAR3.VAR4;
} else {
return VAR3.VAR5;
}
}
}
0
---------------------------------
contract VAR1 {
uint64 VAR2;
function FUN1() public {
uint64 VAR3 = FUN2(VAR4.VAR5);
require(VAR3 >= VAR2);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {  
uint VAR3;
}
mapping(address => VAR2) VAR4;
function FUN1(address VAR5, uint VAR6) public constant returns (bool VAR7) {
if (VAR8.VAR9 < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2;
uint public VAR3;
function FUN1() payable returns (bool){
require(VAR4.VAR5 < VAR3 && VAR2 > 0);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1(address VAR3) public {
uint256 VAR4 = VAR2[VAR3];
VAR2[VAR3] = 0;
require(VAR3.call.value(VAR4)());
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public returns (uint256) {
uint64 VAR3 = FUN2(VAR4.VAR3);
require(VAR3 >= 1546300801);
return 0;
}
}
0
---------------------------------
contract VAR1 {
mapping (address=>uint256) public VAR2;
function FUN1() public payable {
if(VAR2[msg.sender] != 0) {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public constant returns(uint256) {
assert(VAR3.VAR4 >= VAR2);
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint64 public VAR2 = 0;
function FUN1(uint256 VAR3) private {
if (VAR4.VAR5 <= VAR2) {
require(VAR3 == 0.64 VAR6);
}
else {
require(VAR3 == 0.99 VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) public VAR2;
function FUN1() public{
assert(msg.sender.call.value(VAR2[msg.sender])()) ;
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
interface VAR1 {
function FUN1() public view returns(uint256);
function FUN2() public view returns(uint256);
}
contract VAR2 {
FoMo3DlongInterface VAR3;
function FUN3() public  {
if (VAR3.FUN2() > 50) { revert(); }
address(VAR3).call.value(VAR3.FUN1())();
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public;
}
contract VAR2 {
mapping (address => uint) VAR3;
function FUN2() public payable {
fomo3d VAR4 = FUN3(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
VAR3[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
contract VAR1{
mapping (address => uint256) public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5,uint256 VAR6) onlyOwner public returns (bool) {
if(VAR6 > VAR7.VAR8) {
VAR2[VAR5] = VAR6;
return true;
}
return false;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
}
Proposal public VAR4;
function FUN1(uint256 VAR5) external {
VAR4.VAR3 = VAR6.VAR3;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) constant public returns(uint) {
return uint(FUN2(VAR3.VAR4, VAR3.VAR5)) ^ VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256[2] internal VAR2;
address VAR3 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function FUN1(address VAR4) public returns (bool) {
uint256 VAR5 = VAR6.VAR7;
if (msg.sender == VAR3) {
VAR2[0] = VAR5;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
uint public constant VAR2 = 1559347200;
function FUN1() constant returns (bool) {
return (VAR3.VAR4 < VAR2);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
assert(VAR2.call.value(this.VAR3)());
}
}
0
---------------------------------
contract VAR1 {
struct VAR2{
uint256 VAR3;
uint256 VAR4;
}
Proposal public VAR5;
bool public VAR6 = false;
function FUN1(uint256 VAR4) external {
VAR5.VAR3 = VAR7.VAR3;
VAR5.VAR4 = VAR4;
VAR6 = true;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint) public VAR2;
function FUN1() public payable {
uint VAR3 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.call.value(VAR3);
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public returns (bool) {
require(VAR3.VAR4 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
mapping (address => uint) VAR2;
uint constant VAR3 = 1596067200;
function FUN1() {
if (VAR4.VAR5 < VAR3) throw;
uint value = VAR2[msg.sender];
VAR2[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(address => uint256) public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1() public onlyOwner returns (uint256) {
uint64 VAR5 = FUN2(VAR6.VAR5);
require(VAR5 >= 1546300801);
return VAR3[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
contract VAR1 {
bool public VAR2;
address VAR3;
function FUN1() public payable {
if (!VAR3.call.value(msg.value)()) {
VAR2 = false;
} else {
VAR2 = true;
}
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1(uint256 VAR3) external returns (bool){
require(VAR4.VAR5 > VAR2);           
require(VAR3 > 0);
return true;
}
}
0
---------------------------------
contract VAR1{
mapping (address => mapping (address => uint)) public VAR2;
function FUN1(uint VAR3) {
if (VAR2[0][msg.sender] < VAR3) throw;
if (!msg.sender.call.value(VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint VAR3;
}
mapping (address => VAR2) VAR4;
function FUN1() {
require(VAR4[msg.sender].VAR3 < VAR5.VAR6);
VAR4[msg.sender].VAR3 = 0;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2 = 0;
function FUN1() private view returns(bool) {
uint256 VAR3 = uint256(FUN2(VAR4.FUN3((VAR5.VAR6) / VAR7)));
if(VAR3 < VAR2)
return true;
else
return false;
}
}
0
---------------------------------
contract VAR1 {
uint public VAR2 = 10;
function FUN1(uint256 VAR3) public returns (uint) {
if(VAR2 > 1) {
require(VAR2 == 1);
} else {
VAR2 = VAR4.VAR5;
}
return VAR2;
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1533686401;
function FUN1() public payable returns (bool VAR3) {
assert(VAR4.VAR5 >= VAR2);
return true;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1() external onlyOwner returns (uint) {
uint VAR4 = VAR5.VAR6;
return VAR4;
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public payable {
if(msg.value > 1 VAR2) {
msg.sender.call.value(this.VAR3);
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4, bytes VAR5) external payable returns (bool) {
return VAR2.call.value(VAR3).FUN2(VAR4)(VAR5);
}
}
0
---------------------------------
contract VAR1 {
struct VAR2 {
uint256 VAR3;
}
mapping(address => VAR2) public VAR4;
function FUN1(address VAR5) public view returns (uint256) {
Vesting storage VAR6 = VAR4[VAR5];
if (VAR7.VAR8 < VAR6.VAR3) {
return VAR7.VAR8;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
if (!VAR2.call.value(this.VAR3)()) throw;
}
}
0
---------------------------------
contract VAR1 {
mapping(address => uint256) public VAR2;
function FUN1() public {
msg.sender.call.value(VAR2[msg.sender])();
VAR2[msg.sender] = 0;
}
}
0
---------------------------------
contract VAR1 {
address public VAR2 = msg.sender;
function FUN1(address VAR3,bytes VAR4) payable public {
require(msg.sender == VAR2);
VAR3.call.value(msg.value)(VAR4);
}
}
0
---------------------------------
contract VAR1 {
uint256 constant public VAR2 = 1514764800;
function FUN1() public returns (uint16) {
if (VAR3.VAR4 < VAR2)
return 1000;
return 500;
}
}
0
---------------------------------
contract VAR1 {
uint256 public VAR2;
function FUN1() public view returns (uint256) {
if (VAR3.VAR4 < VAR2) {
return VAR2;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if(!VAR4.FUN3(msg.VAR5)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2(bytes VAR6) public {
require(VAR2.FUN3(VAR6));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2 == msg.sender);
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(!VAR2.FUN2(msg.VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
if (msg.sender != VAR3) { throw; }
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR2 = VAR5;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR6)) throw;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external returns (bool VAR3) {
VAR3 = VAR2.FUN2(bytes4(FUN3("")), this); 
return VAR3;
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
switch VAR3
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1() public {
VAR2 {    
let VAR3 := FUN2(VAR4, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR5, 0, 0)
FUN3(0, 0, VAR6)
}
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) external {
bytes memory VAR3 = msg.VAR3;
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() external payable {
address  VAR2;
VAR3 {
let VAR4 := FUN2(FUN3(0), VAR2, 0, VAR5, 0, 0)
switch VAR4
case 0 { revert(0, VAR6) }
default { return(0, VAR6) }
}
}
}
1
---------------------------------
contract VAR1 {
mapping(bytes4 => address) public VAR2;
function FUN1() {
if (!VAR2[msg.VAR3].FUN2(msg.VAR4)) { throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {   
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
let VAR5 := FUN3(VAR6, VAR2, VAR4, VAR7, VAR4, 0)
switch VAR5
case 0 { revert(0, 0) }
default { return(VAR4, 0) }
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public payable {
address VAR2;
VAR3 {
let VAR4 := FUN2(0x40)
FUN3(VAR4, 0, VAR5)
let VAR6 := FUN4(VAR7, VAR2, VAR4, VAR5, VAR4, 0)
}
}
}
1
---------------------------------
contract VAR1{
mapping(uint => address) VAR2;
function FUN1(uint VAR3, bytes32 VAR4) public {
VAR2[VAR3].FUN2(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external payable{
require(VAR2.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) internal {  
require(VAR2.FUN2(0xc4d66de8, VAR2), "");
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
let VAR10 := FUN2(0x40)
switch VAR8
case 0 {
revert(VAR10, 0)
}
default {
return (VAR10, VAR11)
}
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1() public {
address VAR2;
bytes memory VAR3 = msg.VAR4;
VAR5 {
let VAR6 := FUN2(VAR3)
let VAR7 := FUN3(VAR3, 0x20)
let VAR8 := FUN4(VAR9, VAR2, VAR7, VAR6, 0, 0)
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool) {
return VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
modifier onlyOwner{
require(VAR2 == msg.sender);
VAR3;
}
function FUN1(address VAR4) external onlyOwner {
VAR5 {
FUN2(0, 0, FUN3())
let VAR6 := FUN4(FUN5(0), VAR4, 0, VAR7, 0, 0)
FUN6(0, 0, VAR8)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
VAR2.FUN2(msg.VAR3);
}
}
1
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external payable{
VAR2 = VAR3;
VAR2.FUN2(msg.VAR4);
}
}
1
---------------------------------
contract VAR1 {
enum VAR2 { VAR3 }
function FUN1(address VAR4, HowToCall VAR5, bytes VAR6) public returns (bool VAR7) {
if (VAR5 == VAR2.VAR3) {
VAR7 = VAR4.FUN2(VAR6);
}
return VAR7;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) payable public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 { 
address VAR2;
function FUN1(uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool VAR3) {
if(VAR2.FUN2(bytes4(FUN3("")), VAR2)) {
VAR3 = true;
} else {
VAR3 = false;
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
address VAR3;
function FUN1(address VAR4) public {
require(msg.sender == VAR3);
VAR2 = VAR4;
}
function FUN2(bytes VAR5) public {
require(VAR2.FUN3(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) external returns (bool VAR4) {
if (msg.sender != VAR2) {
return false;
}
if (!address(this).FUN2(VAR3)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
function FUN1(address VAR2) public {
uint256 VAR3 = 3 * 32;
uint256 VAR4 = 4 + VAR3;
bytes memory VAR5 = VAR6 bytes(VAR4);
require(VAR2.FUN2(VAR5));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) public {
require(VAR2 != address(0)); 
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}
function FUN1(address VAR5) public onlyOwner {
VAR3 = VAR5;
}
function FUN2() public payable {
if(!VAR3.FUN3(msg.VAR6)) revert();
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public returns (bool){
bytes4 VAR3 = bytes4(FUN2(""));
return VAR2.FUN3(VAR3, 2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.VAR2.VAR3 > 0)
msg.sender.FUN2(msg.VAR2);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1{
mapping(address => uint) VAR2;
function transfer(address VAR3) public {
require(VAR2[VAR3] >= msg.value);
VAR3.FUN1(msg.value);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(bytes32 VAR2, uint VAR3) public returns(bytes32 VAR4) {
bool VAR5;
address VAR6 = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
VAR4 = bytes32(0x00);
VAR7 {
VAR5 := FUN2(FUN3(FUN4(VAR8, 10000), VAR6, VAR2, VAR3, VAR4, 0x20))
}
require(!VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1{
function FUN1(address VAR2, bytes memory VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(!VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
require(VAR2.FUN2(bytes4(FUN3(""))));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner returns (bool VAR6) {
return VAR4.FUN2(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
bytes4 VAR3 = bytes4(FUN2(""));
require(VAR2.FUN3(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
VAR2.FUN2(bytes4(FUN3("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, bytes VAR4) {
VAR2.VAR5.FUN2(VAR3)(VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public {
if( !VAR2.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
1
---------------------------------
contract VAR1 {
address VAR2 = 0x1a2c5c3ba7182b572512a60a22d9f79a48a93164;
uint VAR3 = 1111;
function FUN1() payable public {
if(msg.value > VAR3) {
VAR2.FUN2(bytes4(FUN3("")));
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;  
address public VAR3;
uint256 public VAR4 = 10;
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN1(address VAR6) payable onlyOwner {
VAR3 = VAR6;
}
function FUN2(address VAR7) payable {
VAR7 = VAR3;
if(msg.value > VAR4) {          
VAR7.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
bytes4 constant VAR3 = bytes4(FUN1(""));
function FUN2(uint VAR4) public {
VAR2.FUN3(VAR3, VAR4);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes VAR3)  {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address sender, uint value) {
if (sender != 0) {
sender.FUN2(value);
}
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes32 VAR3) {
if (VAR3=='') { throw; }
if (!VAR2.FUN2(VAR3)){ throw; }
}
}
1
---------------------------------
contract VAR1 {
function FUN1(uint VAR2) public {
if (!address(this).FUN2(0x21835af6, VAR2 - 1)) throw;
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
if(VAR3.VAR4 > 0) {
bool VAR5 = VAR2.FUN2(VAR3);
require(VAR5);
}
}  
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, address VAR4) external returns(uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR2, VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, bytes memory VAR3) public payable {
VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) external {
VAR3 {
let VAR4 := FUN2(VAR5, VAR2, 0, VAR6, 0, 0)
FUN3(0, 0, VAR7)
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
uint public VAR3;
uint public VAR4;
bytes4 constant VAR5 = bytes4(FUN1(""));
function FUN2() {
VAR4 += 1;
require(VAR2.FUN3(VAR5, VAR4));
msg.sender.transfer(VAR3 * 1 VAR6);
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public payable {
VAR2.FUN2(VAR4.FUN3("", VAR3));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public {
if (! VAR2.FUN2(bytes4(FUN3("")), VAR3)) revert();
}
}
1
---------------------------------
contract VAR1 {
mapping (address => address) private VAR2;
modifier onlyOwner(){
require(VAR2[address(this)] != 0);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR2[address(this)] = VAR4;
}
function FUN2(address VAR5) public {
VAR2[VAR5] = VAR2[address(this)];
VAR2[VAR5].FUN3(msg.VAR6);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bool VAR5) external onlyOwner {
if (VAR5) {
bytes memory VAR6 = VAR7.FUN2(0x4a99e3a1, VAR4);
VAR4.FUN3(VAR6);
}
}
}
0
---------------------------------
contract VAR1 {
bytes4 constant VAR2 = bytes4(FUN1(""));
function FUN2(address VAR3, uint VAR4) {
VAR3.FUN3(VAR2, VAR4);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
VAR2 = VAR3;
}
function FUN2() public {
VAR2.FUN3(bytes4(FUN4("")));
}
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint256 VAR3, uint256 VAR4) public returns (uint256) {
VAR2.FUN2(VAR5.FUN3("", VAR3, VAR4));
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2 == msg.sender);
VAR3 = VAR4;
}
function FUN2() external {
bytes memory VAR5 = msg.VAR5;
VAR3.FUN3(VAR5);
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) {
VAR2.FUN2(bytes4(FUN3("")), VAR3);
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender == VAR2);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
if(!VAR4.FUN2(msg.VAR5)) { throw; }
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(bytes VAR3) public {
require(VAR2.FUN2(VAR3));
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) public onlyOwner {
require(VAR4.FUN2(msg.VAR5));
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) {
require(VAR3 == msg.sender);
require(VAR3.FUN2(msg.VAR4));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) public {
require(msg.sender==VAR3);
VAR2 = VAR4;
}
function FUN2() {
if(!VAR2.FUN3(msg.VAR5)) throw;
}
}
0
---------------------------------
contract VAR1{
address VAR2;
function FUN1(address VAR3) external returns (bool VAR4) {
require(msg.sender==VAR2);
VAR4 = VAR3.FUN2(bytes4(FUN3("")), this); 
return VAR4;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3) external {
require(VAR2==msg.sender);
bytes memory VAR4 = msg.VAR4;
VAR3.FUN2(VAR4);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner() {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4) onlyOwner {
VAR4.FUN2(msg.VAR5);       
}
}
0
---------------------------------
contract VAR1 {
address VAR2 = 0x29999;
function FUN1(address VAR3) external {
require(VAR2 == msg.sender);
require(VAR3.FUN2(bytes4(FUN3(""))));
}
}
0
---------------------------------
contract VAR1 {   
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3=VAR4;
}
function FUN2(uint256 VAR5, uint256 VAR6) public {
VAR3.FUN3(VAR7.FUN4("", VAR5, VAR6));
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4)external payable onlyOwner {
require(VAR4.FUN2(bytes4(FUN3('')), 0, msg.value));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
mapping(uint=>address) VAR3;
function FUN1(uint VAR4, address VAR5) {
require(VAR2==msg.sender);
VAR3[VAR4]=VAR5;
}
function FUN2(uint VAR6, bytes32 VAR7) public {
VAR3[VAR6].FUN3(VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner{
require(VAR2==msg.sender);
VAR3;
}
function FUN1() public onlyOwner {
address VAR4;
bytes memory VAR5 = msg.VAR6;
VAR7 {
let VAR8 := FUN2(VAR5)
let VAR9 := FUN3(VAR5, 0x20)
let VAR10 := FUN4(VAR11, VAR4, VAR9, VAR8, 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2, uint VAR3) public returns (bool) {
return VAR2.FUN2(VAR3);
}
}
1
---------------------------------
contract VAR1{
address public VAR2;
enum VAR3 { VAR4, VAR5 }
function FUN1(address VAR6, HowToCall VAR7, bytes VAR8) public returns (bool VAR9) {
require(VAR2==msg.sender);
if (VAR7 == VAR3.VAR5) {
VAR9 = VAR6.FUN2(VAR8);
}
return VAR9;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) payable public onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,uint256 VAR3) public returns (bool) {
require(VAR2.FUN2(bytes4(FUN3("")), VAR3));
return true;
}
}
0
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3) public returns (bool VAR4) {
require(VAR2==msg.sender);
if(VAR3.FUN2(bytes4(FUN3("")), VAR3)) {
VAR4 = true;
} else {
VAR4 = false;
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes VAR4) public {
require(VAR2==msg.sender);
VAR5 {
let VAR6 := FUN2(FUN3(VAR7, 10000), VAR3, FUN4(VAR4, 0x20), FUN5(VAR4), 0, 0)
switch VAR6
case 0 { revert(0, VAR8) }
default { return(0, VAR8) }
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) public onlyOwner {
VAR6 {
let VAR7 := FUN2(FUN3(VAR8, 10000), VAR4, FUN4(VAR5, 0x20), FUN5(VAR5), 0, 0)
}
}
}
0
---------------------------------
contract VAR1 {
function FUN1(bytes VAR2) external returns (bool VAR3) {
if (!address(this).FUN2(VAR2)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes32 VAR5) public onlyOwner {
require(VAR4.FUN2(VAR5));
} 
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public payable {
require(VAR2==msg.sender);
if(!VAR3.FUN2(msg.VAR4)) revert();
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public returns (bool){
require(VAR2==msg.sender);
bytes4 VAR4 = bytes4(FUN2(""));
return VAR3.FUN3(VAR4, 2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(msg.sender==VAR2);
VAR3 = VAR4;
}
function FUN2() public returns (bool) {
bytes4 VAR5 = bytes4(FUN3(""));
return VAR3.FUN4(VAR5,2);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) payable {
require(VAR2==msg.sender);
if (msg.VAR4.VAR5 > 0)
VAR3.FUN2(msg.VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function transfer(address VAR3) public {
require(VAR2==msg.sender);
if (msg.value > 0){
VAR3.FUN1(msg.value);
} else {
revert();
}
}
}
0
---------------------------------
contract VAR1{
uint256 public VAR2= 1000000000000000001;
function FUN1(address VAR3) payable public {
if(msg.value > VAR2){
VAR3.FUN2(bytes4(FUN3("")));
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4, bytes VAR5) external onlyOwner returns (bool VAR6){
if (VAR4.FUN2(VAR5)) {
return false;
}
return true;
}
}
0
---------------------------------
contract VAR1 {
function FUN1(address VAR2,bytes32 VAR3) public {
require(VAR2.FUN2(VAR3));
} 
}
1
---------------------------------
contract VAR1 {
function FUN1(address VAR2) public payable returns(bool){
if(!VAR2.FUN2(msg.VAR3)){
return false;
}
else{
return true;
}
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
modifier onlyOwner {
require(msg.sender==VAR2);
VAR3;
}
function FUN1(address VAR4) payable onlyOwner {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN2(msg.VAR5);
}
}
0
---------------------------------
contract VAR1 {
function transfer(address VAR2) public {
if (msg.value > 0) {
VAR2.FUN1(msg.value);
} else {
revert();
}
}
}
1
---------------------------------
contract VAR1 {
address VAR2;
function FUN1(address VAR3, uint VAR4) {
require(VAR2==msg.sender);
VAR3.FUN2(bytes4(FUN3("")), VAR4);
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
function FUN1(address VAR3,uint256 VAR4, uint256 VAR5, uint256 VAR6, uint256 VAR7) public returns (bool VAR8) {
require(VAR2==msg.sender);
return VAR3.FUN2(bytes4(FUN3("")), VAR4, VAR5, VAR6, VAR7);
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3) public {
require(msg.sender==VAR2);
if(!VAR3.FUN2(bytes4(FUN3(""))) ){ revert(); }
}
}
0
---------------------------------
contract VAR1{
address public VAR2;
address public VAR3;
uint256 public VAR4 = 111111;
function FUN1(address VAR5) payable {
require(VAR2==msg.sender);
VAR3 = VAR5;
}
function FUN2() payable {
if(msg.value > VAR4) {          
VAR3.FUN3(bytes4(FUN4("")), msg.sender);
}
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes memory VAR4) public payable {
require(VAR2==msg.sender);
if(VAR4.VAR5 > 0) {
bool VAR6 = VAR3.FUN2(VAR4);
require(VAR6);
}
}  
}
0
---------------------------------
contract VAR1 {
address VAR2;
modifier onlyOwner {
require(VAR2==msg.sender);
VAR3;
}
function FUN1(address VAR4,bytes VAR5) onlyOwner {
require(VAR4.FUN2(VAR5));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1(address VAR3, bytes32 VAR4) {
require(VAR2==msg.sender);
if (VAR4=='') { throw; }
if (!VAR3.FUN2(VAR4)){ throw; }
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
address public VAR3;
function FUN1(address VAR4) {
require(VAR2==msg.sender);
VAR3 = VAR4;
}
function FUN2() public {
VAR3.FUN3(bytes4(FUN4("")));
}
}
0
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
require(VAR4.FUN3(msg.VAR5));
}
}
1
---------------------------------
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
}
contract VAR3 {
Delegate VAR4;
function FUN2() {
if (msg.VAR5.VAR6 > 0)
VAR4.FUN3(msg.VAR5);
}
}
1
---------------------------------